<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Student Scanner</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest" />
  <meta name="theme-color" content="#0b57d0" />
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(()=>{});
    }
  </script>

  <style>
    :root { --fg:#0b1320; --muted:#5e6b7a; --brand:#0b57d0; --bg:#f6f8fb; }
    html,body { height:100%; }
    body {
      margin:0; font:16px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:var(--fg); background:var(--bg);
      display:flex; align-items:center; justify-content:center; min-height:100dvh;
    }
    .card {
      width:min(920px, 96vw); background:#fff; border-radius:18px; padding:20px 20px 16px;
      box-shadow:0 10px 30px rgba(0,0,0,.06);
    }
    h1 { margin:0 0 4px 0; font-size:22px; }
    .muted { color:var(--muted); font-size:13px; }
    .row { display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap; }
    .col { flex:1 1 320px; }
    .panel {
      background:#fafbff; border:1px solid #eef1f7; border-radius:14px; padding:14px;
    }
    #status { font-weight:600; }
    #result { font-size:17px; margin-top:6px; }
    table { width:100%; border-collapse:collapse; font-size:14px; }
    th,td { padding:8px 6px; border-bottom:1px solid #edf1f6; text-align:left; }
    th { font-weight:600; color:#667; background:#f8f9fc; }
    .ok { color:#0a7c2f; font-weight:600; }
    .err { color:#b00020; font-weight:600; }
    .name { font-weight:700; }
    .code { color:#556; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .input-wrap { display:flex; gap:8px; align-items:center; }
    input[type=text] {
      flex:1; padding:10px 12px; font-size:18px; border-radius:12px; border:1px solid #cfd7e3; outline:none;
    }
    .swatch{display:inline-block;width:10px;height:10px;border-radius:50%;vertical-align:middle;margin-right:6px;border:1px solid #ccd3de}
    button {
      cursor:pointer; border:none; border-radius:12px; padding:10px 14px; font-weight:600; background:var(--brand); color:#fff;
    }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eaf7ea; color:#0a7c2f; font-size:12px; }
    .scans-pane{
      max-height: 360px;     /* ~10 rows */
      overflow-y: auto;
      border: 1px solid #e5e9f2;
      border-radius: 8px;
      background: #fff;
    }
    
    /* keep header visible while scrolling */
    .scans-pane thead th{
      position: sticky;
      top: 0;
      background: #f7f9fc;
      z-index: 1;
      box-shadow: 0 1px 0 rgba(0,0,0,0.06);
    }
    
    /* slightly tighter table so 10 fit nicely */
    #historyTbl td, #historyTbl th{ padding: 8px 10px; line-height: 1.2; }
    .bad { color:#b00020; font-weight:600; }
    .queued { color:#8a5a00; font-weight:600; }
  </style>
</head>
<body>
  <div class="card">
    <div id="locModal" style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:9999;">
      <div style="background:#fff; width:min(360px, 92vw); border-radius:14px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.2)">
        <div style="font-weight:700; margin-bottom:8px;">Select your location</div>
        <div class="muted" style="margin-bottom:12px">This will be saved and attached to each scan.</div>
        <select id="locSelect" style="width:100%; padding:10px; border:1px solid #cfd7e3; border-radius:10px; margin-bottom:12px">
          <option value="">Loading…</option>
        </select>
        <div style="display:flex; gap:8px; justify-content:flex-end;">
          <button id="locCancelBtn" style="background:#e5e9f2; color:#333">Cancel</button>
          <button id="locSaveBtn">Save</button>
        </div>
      </div>
    </div>
    <h1>Student Scanner 
      <span class="pill" id="onlinePill">Online</span>
      <span class="pill" id="locationPill" style="margin-left:6px; cursor:pointer;" title="Click to change location">Set location</span>
    </h1>
    <div class="muted">RFID keyboard-wedge or keypad: enter OSIS/RFID + Enter. Shows Name, Locker #/Color, and scan time.</div>

    <div class="row" style="margin-top:14px">
      <!-- Left: Live status + last result + manual entry -->
      <div class="col">
        <div class="panel">
          <div id="status">Ready. Scan a card…</div>
          <div id="result"></div>

          <hr style="border:none;border-top:1px solid #edf1f6; margin:12px -14px" />

          <div class="muted" style="margin-bottom:6px">Manual entry (keypad or typing):</div>
          <form id="manualForm" class="input-wrap" autocomplete="off">
            <input id="manualInput" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="Type OSIS or RFID and press Enter" />
            <button type="submit">Enter</button>
          </form>
          <div class="muted" style="margin-top:6px">Tip: The field keeps focus—good for external keypads.</div>
        </div>
      </div>

      <!-- Right: Recent scans -->
      <div class="col">
        <div class="panel">
          <div class="muted" style="margin-bottom:8px">Recent scans (local)</div>
          <div id="scansPane" class="scans-pane">
            <table id="historyTbl" aria-label="Scan history">
              <thead>
                <tr>
                  <th style="width:30%">Name</th>
                  <th style="width:20%">Code</th>
                  <th style="width:22%">Locker</th>
                  <th style="width:28%">Time</th>
                </tr>
              </thead>
              <tbody id="historyBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="muted" style="margin-top:10px">
      Configure <span class="code">API_BASE</span> in the script below.
    </div>
  </div>

  <script>
  /**************** CONFIG — EDIT ME ****************/
  // Apps Script Web App /exec URL
  const API_BASE = 'https://red-cake-77d5.evazquez-3e0.workers.dev/';
  (async () => {
    try {
      await fetch(API_BASE, {
        method: 'POST',
        body: new URLSearchParams({ action: 'ping' })
      });
    } catch (_) {}
  })();
    
  // Keyboard-wedge behavior
  const STRIP_PREFIX = true;
  const SCAN_CHAR_MS = 30;        // max ms between chars to treat input as "scanner"
  const DEDUPE_MS = 1000;
  const HISTORY_VISIBLE = 10;   // ~10 rows visible in the pane
  const HISTORY_MAX = 1000;     // keep up to 1000 rows in memory for scrolling

  /**************** STATE ****************/
  let buffer = "", lastTs = 0, resetTimer = null;
  let lastScanValue = "", lastScanAt = 0;
  let IS_MODAL_OPEN = false;

  const statusEl = document.getElementById('status');
  const resultEl = document.getElementById('result');
  const historyBody = document.getElementById('historyBody');
  const manualInput = document.getElementById('manualInput');
  const onlinePill = document.getElementById('onlinePill');
  const locationPill = document.getElementById('locationPill');

  const QUEUE_KEY = 'scanQueueV1';
  const LOC_KEY = 'scannerLocationV1';

  function getLocation(){ return localStorage.getItem(LOC_KEY) || ''; }
  function setLocation(v){ localStorage.setItem(LOC_KEY, v || ''); updateLocationPill(); }
  
  async function apiGetLocations(){
    const r = await fetch(API_BASE, { method:'POST', body: new URLSearchParams({ action:'locations' }) });
    const ct = r.headers.get('content-type')||'';
    const text = await r.text();
    if (!r.ok) throw new Error(`HTTP ${r.status} ${text.slice(0,120)}`);
    if (!ct.includes('application/json')) throw new Error('Bad content-type for locations');
    const data = JSON.parse(text);
    if (!data.ok) throw new Error(data.error || 'locations_error');
    return data.locations || [];
  }
  
  async function promptForLocation(force=false){
    if (!force && getLocation()) { updateLocationPill(); return; }
  
    const modal = document.getElementById('locModal');
    const sel   = document.getElementById('locSelect');
    const btnOK = document.getElementById('locSaveBtn');
    const btnX  = document.getElementById('locCancelBtn');
  
    // Populate list
    sel.innerHTML = `<option value="">Loading…</option>`;
    modal.style.display = 'flex';
    setModalOpen(true);
    try {
      const list = await apiGetLocations();
      sel.innerHTML = `<option value="">Select a location…</option>` + list.map(v => `<option>${esc(v)}</option>`).join('');
      const saved = getLocation();
      if (saved) sel.value = saved;
    } catch (e) {
      sel.innerHTML = `<option value="">(Couldn’t load locations)</option>`;
    }
  
    return new Promise(resolve=>{
      const close = (val) => { modal.style.display = 'none'; setModalOpen(false); resolve(val); };
      btnOK.onclick = () => {
        const val = sel.value.trim();
        if (val) { setLocation(val); close(val); } else { alert('Please choose a location.'); }
      };
      btnX.onclick = () => close(getLocation()); // keep existing value or none
      // close on backdrop click
      modal.addEventListener('click', (ev)=>{ if (ev.target === modal) close(getLocation()); }, { once:true });
    });
  }
  
  function updateLocationPill(){
    const pill = document.getElementById('locationPill');
    const v = getLocation();
    pill.textContent = v ? `Location: ${v}` : 'Set location';
    pill.style.background = v ? '#e7f0fe' : '#fff3e0';
    pill.style.color = v ? '#0b57d0' : '#8a5a00';
  }

  function isModalVisible() {
    const m = document.getElementById('locModal');
    return !!m && m.style.display === 'flex';
  }
  function setModalOpen(v){
    IS_MODAL_OPEN = !!v;
  }
    
  function loadQueue(){ try{ return JSON.parse(localStorage.getItem(QUEUE_KEY)||'[]'); }catch{return [];} }
  function saveQueue(q){ localStorage.setItem(QUEUE_KEY, JSON.stringify(q)); }
  async function flushQueue(){
    if (!navigator.onLine) return;
    const q = loadQueue();
    if (!q.length) return;
    const remain = [];
    for (const item of q){
      try{
        const res = await apiLookup(item.code);
        if (res.found){
          // update the existing row if we kept a DOM id; else just inject a “resolved” row
          updateRowToSuccess(item.rowRef ?? pushPendingRow(item.seq, item.code, new Date(item.whenISO)), {
            name: res.name, code: item.code,
            lockerNum: res.locker_number, lockerColor: res.locker_color,
            when: new Date(item.whenISO)
          });
          apiLog({ whenISO:item.whenISO, code:item.code, source:'pwa', resolved:res });
        } else {
          updateRowToNotFound(item.rowRef ?? pushPendingRow(item.seq, item.code, new Date(item.whenISO)),
            item.code, new Date(item.whenISO), res.error, res.reason);
        }
      } catch {
        // still offline or error → keep it
        remain.push(item);
      }
    }
    saveQueue(remain);
  }
  window.addEventListener('online', flushQueue);
  // Try once on load too
  flushQueue();

  function setStatus(t){ statusEl.textContent = t; }
  function vibrate(){ try{ navigator.vibrate?.(30); }catch{} }
  function esc(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function fmtTime(d){ try{ return new Intl.DateTimeFormat(undefined,{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false}).format(d);}catch{return d.toLocaleString();} }

  /**************** API ****************/
  async function apiLookup(code){
    const body = new URLSearchParams({ action:'lookup', code });
  
    // show "Waking server…" only if it's actually slow
    const wakeTimer = setTimeout(() => setStatus('Waking server…'), 700);
  
    // hard timeout so we don't hang forever
    const controller = new AbortController();
    const abortTimer = setTimeout(() => controller.abort(), 8000);
  
    try {
      const r = await fetch(API_BASE, { method:'POST', body, signal: controller.signal });
  
      // read once; decide based on content-type
      const ct = r.headers.get('content-type') || '';
      const text = await r.text();
  
      if (!r.ok) throw new Error(`HTTP ${r.status} ${text.slice(0,120)}`);
  
      if (!ct.includes('application/json')) {
        // Worker will pass HTML on upstream errors; surface that
        throw new Error('Upstream HTML (not JSON): ' + text.slice(0,120));
      }
  
      return JSON.parse(text);
    } finally {
      clearTimeout(wakeTimer);
      clearTimeout(abortTimer);
      // don't leave "Waking server…" hanging if an error occurred before UI updates
      if (statusEl.textContent.includes('Waking server')) setStatus('Ready.');
    }
  }
  function makeLogId({ whenISO, code }) {
    // simple stable key; good enough for one school day
    return `${whenISO}|${code}|${getLocation()||''}|${DEVICE_ID}`;
  }
  
  const DEVICE_ID = (localStorage.getItem('scannerDeviceId') ||
    (localStorage.setItem('scannerDeviceId', crypto.randomUUID()), localStorage.getItem('scannerDeviceId')));
  
  async function apiLog(entry){
    const whenISO = entry.whenISO || new Date().toISOString();
    const log_id = makeLogId({ whenISO, code: entry.code || '' });
    const body = new URLSearchParams({
      action:'log',
      log_id,                                 // <-- NEW
      whenISO,
      code: entry.code || '',
      source: entry.source || 'pwa',
      resolved_name:  entry.resolved?.name  || '',
      resolved_osis:  entry.resolved?.osis  || '',
      resolved_lnum:  entry.resolved?.locker_number || '',
      resolved_lcol:  entry.resolved?.locker_color  || '',
      location: getLocation() || '',
      device_id: DEVICE_ID                    // <-- optional, useful for audits
    });
    try { await fetch(API_BASE, { method:'POST', body }); } catch {}
  }

  /**************** SCAN FLOW ****************/

  let scanSeq = 0;
  
  function onScan(code){
    const when = new Date();
    const seq = ++scanSeq;
    const row = pushPendingRow(seq, code, when);
  
    // If offline, queue and mark row
    if (!navigator.onLine){
      markRowQueued(row);
      const q = loadQueue();
      q.push({ seq, code, whenISO: when.toISOString() });
      saveQueue(q);
      setStatus('Offline — queued');
      return;
    }
  
    // Otherwise do the normal async lookup
    void (async () => {
      try {
        const res = await apiLookup(code); // with timeout/abort inside
        if (res.found) {
          updateRowToSuccess(row, { name: res.name, code, lockerNum: res.locker_number, lockerColor: res.locker_color, when });
          apiLog({ whenISO: when.toISOString(), code, source: 'pwa', resolved: res });
        } else {
          updateRowToNotFound(row, code, when, res.error, res.reason);
        }
      } catch (err) {
        // Treat network aborts/timeouts as offline-queue
        if (!navigator.onLine || (err.name === 'AbortError')){
          markRowQueued(row);
          const q = loadQueue(); q.push({ seq, code, whenISO: when.toISOString() }); saveQueue(q);
          setStatus('Offline — queued');
        } else {
          updateRowToError(row, code, when, err);
        }
      }
    })();
  }
  
  function markRowQueued(tr){
    const first = tr.querySelector('.name');
    if (first) first.innerHTML = '<span class="queued">Queued (offline)</span>';
  }

  function showSuccess(name, code, lockerNum, lockerColor, when){
    resultEl.innerHTML =
      `<div class="ok">OK</div>
       <div class="name">${esc(name || 'Unknown')}</div>
       <div class="code">${esc(code)} — Locker ${esc(lockerNum || '—')} (${esc(lockerColor || '—')})</div>
       <div class="muted">${fmtTime(when)}</div>`;
    pushHistoryRow(name || 'Unknown', code, lockerNum, lockerColor, when);
    setStatus('Ready. Scan next card…');
  }

  function showNotFound(code, when){
    resultEl.innerHTML =
      `<div class="err">Not found</div>
       <div class="code">${esc(code)}</div>
       <div class="muted">${fmtTime(when)}</div>`;
    setStatus('Ready.');
  }

  function showError(err, code, when){
    resultEl.innerHTML =
      `<div class="err">Lookup error</div>
       <div class="code">${esc(code||'')}</div>
       <div class="muted">${fmtTime(when)} — ${esc(err.message||String(err))}</div>`;
    setStatus('Ready.');
  }

  function pushHistoryRow(name, code, lockerNum, lockerColor, when){
    const tr = document.createElement('tr');
    const color = String(lockerColor||'').trim();
    const num   = String(lockerNum||'').trim();
  
    // try to map common color names to CSS colors; fallback to text
    const cssColor = ({
      red:'#e53935', blue:'#1e88e5', green:'#43a047', yellow:'#fdd835',
      purple:'#8e24aa', orange:'#fb8c00', pink:'#d81b60', gray:'#78909c',
      grey:'#78909c', black:'#263238', white:'#fafafa', teal:'#009688'
    })[color.toLowerCase()] || null;
  
    const lockerHtml = (num || color)
      ? (cssColor
          ? `<span class="swatch" style="background:${cssColor}"></span>${esc(num)} <span class="muted">(${esc(color)})</span>`
          : `${esc(num)} <span class="muted">(${esc(color)})</span>`)
      : '—';
  
    tr.innerHTML =
      `<td class="name">${esc(name)}</td>
       <td class="code">${esc(code)}</td>
       <td>${lockerHtml}</td>
       <td>${fmtTime(when)}</td>`;
    historyBody.prepend(tr);
    trimHistory();
  }

  function pushPendingRow(seq, code, when){
    const tr = document.createElement('tr');
    tr.dataset.seq = String(seq);
    tr.innerHTML =
      `<td class="name"><em>…looking up…</em></td>
       <td class="code">${esc(code)}</td>
       <td>—</td>
       <td>${fmtTime(when)}</td>`;
    historyBody.prepend(tr); // newest at top, still preserves input order because we insert on scan
    trimHistory();
    return tr;
  }
  
  function updateRowToSuccess(tr, {name, code, lockerNum, lockerColor, when}){
    const color = (lockerColor||'').trim();
    const cssColor = ({
      red:'#e53935', blue:'#1e88e5', green:'#43a047', yellow:'#fdd835',
      purple:'#8e24aa', orange:'#fb8c00', pink:'#d81b60', gray:'#78909c',
      grey:'#78909c', black:'#263238', white:'#fafafa', teal:'#009688'
    })[color.toLowerCase()] || null;
  
    const lockerHtml = (lockerNum || color)
      ? (cssColor
          ? `<span class="swatch" style="background:${cssColor}"></span>${esc(lockerNum||'')} <span class="muted">(${esc(color)})</span>`
          : `${esc(lockerNum||'')} <span class="muted">(${esc(color)})</span>`)
      : '—';
  
    tr.innerHTML =
      `<td class="name">${esc(name||'Unknown')}</td>
       <td class="code">${esc(code)}</td>
       <td>${lockerHtml}</td>
       <td>${fmtTime(when)}</td>`;
  }
  
  function updateRowToNotFound(tr, code, when, error, reason){
    const msg = error === 'invalid_input'
      ? (reason === 'leading_zero_osis'
          ? 'Leading-zero OSIS — scan card.'
          : 'Digits only.')
      : 'Not found';
    tr.innerHTML =
      `<td class="name"><span class="bad">${esc(msg)}</span></td>
       <td class="code">${esc(code)}</td>
       <td>—</td>
       <td>${fmtTime(when)}</td>`;
  }
  
  function updateRowToError(tr, code, when, err){
    tr.innerHTML =
      `<td class="name"><span class="bad">Lookup error</span></td>
       <td class="code">${esc(code)}</td>
       <td>—</td>
       <td>${fmtTime(when)}</td>`;
  }
  
  function trimHistory(){
    while (historyBody.children.length > HISTORY_MAX) {
      historyBody.lastChild.remove();
    }
  }




  /**************** KEYBOARD-WEDGE LISTENER ****************/
  const SCAN_GAP_MS = 10;   // <=18ms between keys => scanner. Humans are usually >40–60ms
  let lastKeyTs = 0;
  let wedgeBuf = "";
  let wedgeResetTimer = null;
  
  window.addEventListener('keydown', (e)=>{
    if (IS_MODAL_OPEN || isModalVisible()) return;
    keepFocus();
  
    const now = performance.now();
    const gap = now - (lastKeyTs || now);
    lastKeyTs = now;
  
    // Handle Enter: prefer scanner buffer if present; else use the input value via form submit
    if (e.key === 'Enter'){
      const finished = wedgeBuf;
      wedgeBuf = "";
      if (finished){
        e.preventDefault();            // consume Enter for scanner flows
        onScan(finished);
        manualInput.value = '';        // keep the box clean after scans
      }
      return;
    }
  
    // Printable characters
    if (e.key.length === 1){
      const looksLikeScanner = gap <= SCAN_GAP_MS && (wedgeBuf.length > 0 || gap > 0);
  
      if (looksLikeScanner){
        // Confident it's a scanner burst: build our own buffer and keep the box clean
        e.preventDefault();
        wedgeBuf += e.key;
      } else {
        // Let humans type normally into the field; DON'T build wedgeBuf here.
        // We'll read manualInput.value on submit.
      }
    }
  
    // Reset wedge buffer if typing pauses
    clearTimeout(wedgeResetTimer);
    wedgeResetTimer = setTimeout(()=> { wedgeBuf = ""; }, 200);
  }, true);
  
  
  /**************** MANUAL ENTRY FORM ****************/
  document.getElementById('manualForm').addEventListener('submit', (e)=>{
    e.preventDefault();
    if (IS_MODAL_OPEN || isModalVisible()) return;
    const v = manualInput.value.trim();
    if (v) onScan(v);          // human path uses the field value
    manualInput.value = '';
    keepFocus();
  });

  function keepFocus(){
    if (IS_MODAL_OPEN || isModalVisible()) return;  // ⬅️ do nothing while modal open
    if (document.activeElement !== manualInput) manualInput.focus({preventScroll:true});
    manualInput.setSelectionRange(manualInput.value.length, manualInput.value.length);
  }
  keepFocus(); setInterval(keepFocus, 1000);

  /**************** ONLINE/OFFLINE INDICATOR ****************/
  function updateOnlinePill(){
    const on = navigator.onLine;
    onlinePill.textContent = on ? 'Online' : 'Offline';
    onlinePill.style.background = on ? '#eaf7ea' : '#fff3e0';
    onlinePill.style.color = on ? '#0a7c2f' : '#8a5a00';
  }
  window.addEventListener('online', updateOnlinePill);
  window.addEventListener('offline', updateOnlinePill);
  updateOnlinePill();
  // Ask for location on load (once)
  promptForLocation(false);
  
  // Allow changing later
  document.getElementById('locationPill').addEventListener('click', () => {
    promptForLocation(true);
  });

  </script>
</body>
</html>
