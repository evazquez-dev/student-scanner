<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Student Scanner</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest" />
  <meta name="theme-color" content="#0b57d0" />
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(()=>{});
    }
  </script>

  <style>
    :root { --fg:#0b1320; --muted:#5e6b7a; --brand:#0b57d0; --bg:#f6f8fb; }
    html,body { height:100%; }
    body {
      margin:0; font:16px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:var(--fg); background:var(--bg);
      display:flex; align-items:center; justify-content:center; min-height:100dvh;
    }
    .card {
      width:min(920px, 96vw); background:#fff; border-radius:18px; padding:20px 20px 16px;
      box-shadow:0 10px 30px rgba(0,0,0,.06);
    }
    h1 { margin:0 0 4px 0; font-size:22px; }
    .muted { color:var(--muted); font-size:13px; }
    .row { display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap; }
    .col { flex:1 1 320px; }
    .panel {
      background:#fafbff; border:1px solid #eef1f7; border-radius:14px; padding:14px;
    }
    #status { font-weight:600; }
    #result { font-size:17px; margin-top:6px; }
    table { width:100%; border-collapse:collapse; font-size:14px; }
    th,td { padding:8px 6px; border-bottom:1px solid #edf1f6; text-align:left; }
    th { font-weight:600; color:#667; background:#f8f9fc; }
    .ok { color:#0a7c2f; font-weight:600; }
    .err { color:#b00020; font-weight:600; }
    .name { font-weight:700; }
    .code { color:#556; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .input-wrap { display:flex; gap:8px; align-items:center; }
    input[type=text] {
      flex:1; padding:10px 12px; font-size:18px; border-radius:12px; border:1px solid #cfd7e3; outline:none;
    }
    .swatch{display:inline-block;width:10px;height:10px;border-radius:50%;vertical-align:middle;margin-right:6px;border:1px solid #ccd3de}
    button {
      cursor:pointer; border:none; border-radius:12px; padding:10px 14px; font-weight:600; background:var(--brand); color:#fff;
    }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eaf7ea; color:#0a7c2f; font-size:12px; }
    .scans-pane{
      max-height: 360px; overflow-y: auto; border: 1px solid #e5e9f2; border-radius: 8px; background: #fff;
    }
    .scans-pane thead th{ position: sticky; top: 0; background: #f7f9fc; z-index: 1; box-shadow: 0 1px 0 rgba(0,0,0,0.06); }
    #historyTbl td, #historyTbl th{ padding: 8px 10px; line-height: 1.2; }
    .bad { color:#b00020; font-weight:600; }
    .queued { color:#8a5a00; font-weight:600; }
    .allowed-badge { color:#0a7c2f; font-weight:700; }
    .not-allowed-badge { color:#b00020; font-weight:700; }
    .badge{display:inline-block;padding:2px 10px;border-radius:999px;font-size:12px;font-weight:700}
    .badge--out{background:#eaf7ea;color:#b00020}  /* red ONLY for OUT */
    .badge--in{background:#eaf7ea;color:#0a7c2f}   /* green for IN */
    .badge--na{background:#fdecea;color:#b00020}      /* neutral for NOT ALLOWED */
    
    .flag{display:inline-flex;align-items:center;gap:6px;font-size:12px;color:#334;user-select:none}
    .flag input{accent-color:#0b57d0}

    /* Modal topmost + inert safety */
    #locModal { position:fixed; inset:0; z-index: 2147483000; }
    .card[inert] { pointer-events: none; }
    .pill--bad { background:#fdecea !important; color:#b00020 !important; }
    .pill--warn{ background:#fff3e0 !important; color:#8a5a00 !important; }
  </style>
</head>
<body>
  <!-- Location modal -->
  <div id="locModal" style="background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center;">
    <div style="background:#fff; width:min(360px, 92vw); border-radius:14px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.2)">
      <div style="font-weight:700; margin-bottom:8px;">Select your location</div>
      <div class="muted" style="margin-bottom:12px">This will be saved and attached to each scan.</div>
      <select id="locSelect" style="width:100%; padding:10px; border:1px solid #cfd7e3; border-radius:10px; margin-bottom:12px">
        <option value="">Loading‚Ä¶</option>
      </select>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="locCancelBtn" style="background:#e5e9f2; color:#333">Cancel</button>
        <button id="locSaveBtn">Save</button>
      </div>
    </div>
  </div>

  <div class="card">
    <h1>Student Scanner 
      <span class="pill" id="onlinePill">Online</span>
      <span class="pill" id="locationPill" style="margin-left:6px; cursor:pointer;" title="Click to change location">Set location</span>
      <span class="pill" id="batteryPill" style="margin-left:6px">üîã --%</span>
      <span class="pill" id="netPill" style="margin-left:6px">Wi-Fi ‚Ä¶</span>
    </h1>
    <div class="muted">RFID keyboard-wedge or keypad: enter OSIS/RFID + Enter. Shows Name, Locker #/Color, and scan time.</div>

    <div class="row" style="margin-top:14px">
      <!-- Left -->
      <div class="col">
        <div class="panel">
          <div id="status">Ready. Scan a card‚Ä¶</div>
          <div id="result"></div>

          <hr style="border:none;border-top:1px solid #edf1f6; margin:12px -14px" />

          <div class="muted" style="margin-bottom:6px">Manual entry (keypad or typing):</div>
          <form id="manualForm" class="input-wrap" autocomplete="off">
            <input id="manualInput" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="Type OSIS or RFID and press Enter" />
            <button type="submit">Enter</button>
          </form>
          <div class="muted" style="margin-top:6px">Tip: The field keeps focus‚Äîgood for external keypads.</div>
        </div>
      </div>

      <!-- Right -->
      <div class="col">
        <div class="panel">
          <div class="muted" style="margin-bottom:8px">Recent scans (local)</div>
          <div id="scansPane" class="scans-pane">
            <table id="historyTbl" aria-label="Scan history">
              <thead>
                <tr>
                  <th style="width:30%">Name</th>
                  <th style="width:20%">Code</th>
                  <th style="width:22%">Locker</th>
                  <th style="width:28%">Time</th>
                </tr>
              </thead>
              <tbody id="historyBody"></tbody>
            </table>
          </div>
        </div>
        <!-- Current OUT list (only visible for Senior Lunch (out-in)) -->
        <div class="panel" id="outPanel" style="margin-top:10px; display:none">
          <div class="muted" style="margin-bottom:8px; display:flex; align-items:center; justify-content:space-between;">
            <span>Currently OUT ‚Äî Senior Lunch</span>
            <button id="refreshRosterBtn" style="background:#e7f0fe; color:#0b57d0; padding:6px 10px; border-radius:10px; font-size:12px;">
              Refresh roster
            </button>
          </div>
          <div id="outPane" class="scans-pane" style="max-height: 240px">
            <table id="outTbl" aria-label="Currently OUT">
              <thead>
                <tr>
                  <th style="width:40%">Name</th>
                  <th style="width:20%">OSIS</th>
                  <th style="width:40%">Since</th>
                </tr>
              </thead>
              <tbody id="outBody"></tbody>
            </table>
          </div>
        </div>
        <!-- Current IN list (only visible for Bathroom locations) -->
        <div class="panel" id="bathPanel" style="margin-top:10px; display:none">
          <div class="muted" style="margin-bottom:8px; display:flex; align-items:center; justify-content:space-between;">
            <span id="bathPanelTitle">Currently IN ‚Äî Bathroom</span>
            <button id="bathRefreshBtn" style="background:#e7f0fe; color:#0b57d0; padding:6px 10px; border-radius:10px; font-size:12px;">
              Refresh roster
            </button>
          </div>
          <div id="bathPane" class="scans-pane" style="max-height: 240px">
            <table id="bathTbl" aria-label="Currently IN (Bathroom)">
              <thead>
                <tr>
                  <th style="width:40%">Name</th>
                  <th style="width:20%">OSIS</th>
                  <th style="width:20%">Since</th>
                  <th style="width:20%">Capacity</th>
                </tr>
              </thead>
              <tbody id="bathBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="muted" style="margin-top:10px">
      Configure <span class="code">API_BASE</span> in the script below.
    </div>
  </div>

  <script>
  /************** CONFIG **************/
  const API_BASE = 'https://red-cake-77d5.evazquez-3e0.workers.dev/';

  // optional wake-up ping (Worker may not implement "ping"; that's fine)
  (async () => { try {
    await fetch(API_BASE, { method: 'POST', body: new URLSearchParams({ action: 'ping' }) });
  } catch (_) {} })();

  // Static fallback locations (used if Worker doesn't serve `locations`)
  const STATIC_LOCATIONS = [
    'Front Desk','Main Entrance','Cafeteria','Gym','Security','Room 302','Senior Lunch (out-in)'
  ];

  // Keyboard-wedge timing + history
  const SCAN_GAP_MS = 10;
  const DEDUPE_MS = 1000;
  const HISTORY_VISIBLE = 10;
  const HISTORY_MAX = 1000;
  const HISTORY_VISIBLE_DEFAULT = 10;
  const HISTORY_VISIBLE_SENIOR  = 4;

  /************** STATE + DOM **************/
  let IS_MODAL_OPEN = false;
  let IS_LOCATION_LOCKED = false;
  let lastKeyTs = 0, wedgeBuf = "", wedgeResetTimer = null;

  const statusEl = document.getElementById('status');
  const resultEl = document.getElementById('result');
  const historyBody = document.getElementById('historyBody');
  const manualInput = document.getElementById('manualInput');
  const onlinePill = document.getElementById('onlinePill');
  const locationPill = document.getElementById('locationPill');
  const cardEl = document.querySelector('.card');

  const QUEUE_KEY = 'scanQueueV1';
  const LOC_KEY = 'scannerLocationV1';
  const DEVICE_ID = (localStorage.getItem('scannerDeviceId') ||
    (localStorage.setItem('scannerDeviceId', crypto.randomUUID()), localStorage.getItem('scannerDeviceId')));

  function getLocation(){ return localStorage.getItem(LOC_KEY) || ''; }
  function setLocation(v){ localStorage.setItem(LOC_KEY, v || ''); updateLocationPill(); }

  const SPECIAL_LOCATION = 'Senior Lunch (out-in)';  // exact match, case-insensitive ok
  const OUT_KEY = 'seniorOutV1';
  
  function todayKey() {
    // YYYY-MM-DD (local date)
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const day = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${day}`;
  }
  function outBucketKey() {
    // bucket by DATE + LOCATION so each day is independent
    return `${todayKey()}|${(getLocation()||'').toLowerCase()}`;
  }
  function loadOutMap(){
    try { return JSON.parse(localStorage.getItem(OUT_KEY) || '{}'); } catch { return {}; }
  }
  function saveOutMap(map){
    localStorage.setItem(OUT_KEY, JSON.stringify(map));
  }
  function getOutSet(){
    const map = loadOutMap();
    const bucket = outBucketKey();
    return map[bucket] || []; // array of { osis, name, sinceISO }
  }
  function setOutSet(list){
    const map = loadOutMap();
    const bucket = outBucketKey();
    map[bucket] = list;
    saveOutMap(map);
  }
  function isOutNow(osis){
    osis = String(osis||'').trim();
    if (!osis) return false;
    return getOutSet().some(x => x.osis === osis);
  }
  function addOut(osis, name, when=new Date()){
    osis = String(osis||'').trim(); if (!osis) return;
    const list = getOutSet();
    if (!list.some(x => x.osis === osis)) {
      list.unshift({ osis, name: String(name||'').trim(), sinceISO: when.toISOString() });
      setOutSet(list);
    }
  }
  function removeOut(osis){
    osis = String(osis||'').trim(); if (!osis) return;
    const list = getOutSet().filter(x => x.osis !== osis);
    setOutSet(list);
  }
  function isSeniorOutIn(){
    return String(getLocation()||'').toLowerCase() === SPECIAL_LOCATION.toLowerCase();
  }
  function renderOutList(){
    const outPanel = document.getElementById('outPanel');
    const outBody  = document.getElementById('outBody');
    const loc = getLocation();
    const show = String(loc||'').toLowerCase() === SPECIAL_LOCATION.toLowerCase();
    outPanel.style.display = show ? '' : 'none';
    if (!show) return;
  
    const rows = getOutSet();
    outBody.innerHTML = rows.map(r => {
      const when = new Date(r.sinceISO);
      return `<tr>
        <td class="name">${esc(r.name || '‚Äî')}</td>
        <td class="code">${esc(r.osis || '')}</td>
        <td>${fmtTime(when)}</td>
      </tr>`;
    }).join('');
  }

  /************** Lunch helpers **************/
  function setUpdating(on){
    if (on) {
      setStatus('Updating roster‚Ä¶ wait‚Ä¶');
    } else {
      setStatus('Ready. Scan a card‚Ä¶');
    }
  }

  function isLunchLocation(loc){
    const v = String(loc||'').toLowerCase().trim();
    return v === 'lunch' || v === 'lunch 1' || v === 'lunch 2';
  }
  function lunchSlotFromLocation(loc){
    const v = String(loc||'').toLowerCase();
    return v.includes('2') ? 2 : 1;
  }
  function normalizeLunchValue(s){
    const v = String(s||'').toLowerCase().replace(/\s+/g,'').replace('lunch','').replace('group','').replace('l','');
    const m = v.match(/([12])/); return m ? Number(m[1]) : null;
  }
  function isAllowedForLunch(location, lunchValue){
    const need = lunchSlotFromLocation(location);
    const have = normalizeLunchValue(lunchValue);
    return have === need;
  }
  function updateHistoryPaneForLocation(){
    const pane = document.getElementById('scansPane');
    if (!pane) return;
    // Tighten height for 3‚Äì4 rows + header
    pane.style.maxHeight = isSeniorOutIn() ? '140px' : '360px';
  }

  /************** Bathroom helpers **************/
  const BATHROOM_PREFIX = 'Bathroom (';               // exact labels: 'Bathroom (First Floor)', etc.
  const BATH_KEY = 'bathroomInV1';                    // localStorage map of present students
  const BATH_CAP_KEY = 'bathroomCapV1';               // per-location capacity map
  const BATHROOM_CAPACITY_DEFAULT = 2;                // default; can be changed per location
  
  function isBathroomLocation(loc){
    const v = String(loc||'').toLowerCase().trim();
    return v.startsWith('bathroom (');
  }
  
  // date-scoped + location-scoped bucket key for bathroom
  function bathBucketKey() {
    return `${todayKey()}|${(getLocation()||'').toLowerCase()}`;
  }
  
  function loadBathMap(){
    try { return JSON.parse(localStorage.getItem(BATH_KEY) || '{}'); } catch { return {}; }
  }
  function saveBathMap(map){
    localStorage.setItem(BATH_KEY, JSON.stringify(map));
  }
  function getBathSet(){
    const map = loadBathMap();
    const bucket = bathBucketKey();
    return map[bucket] || []; // array of { osis, name, sinceISO }
  }
  function setBathSet(list){
    const map = loadBathMap();
    const bucket = bathBucketKey();
    map[bucket] = list;
    saveBathMap(map);
  }
  function isInBathroom(osis){
    osis = String(osis||'').trim();
    if (!osis) return false;
    return getBathSet().some(x => x.osis === osis);
  }
  function addInBathroom(osis, name, when=new Date()){
    osis = String(osis||'').trim(); if (!osis) return;
    const list = getBathSet();
    if (!list.some(x => x.osis === osis)) {
      list.unshift({ osis, name: String(name||'').trim(), sinceISO: when.toISOString() });
      setBathSet(list);
    }
  }
  function removeFromBathroom(osis){
    osis = String(osis||'').trim(); if (!osis) return;
    const list = getBathSet().filter(x => x.osis !== osis);
    setBathSet(list);
  }
  
  function loadBathCapMap(){
    try { return JSON.parse(localStorage.getItem(BATH_CAP_KEY) || '{}'); } catch { return {}; }
  }
  function saveBathCapMap(map){
    localStorage.setItem(BATH_CAP_KEY, JSON.stringify(map));
  }
  /** Get capacity for current bathroom location. */
  function getBathroomCapacity(loc){
    const map = loadBathCapMap();
    const key = String(loc||'').toLowerCase();
    const n = Number(map[key]);
    return Number.isFinite(n) && n > 0 ? n : BATHROOM_CAPACITY_DEFAULT;
  }
  /** Optional helper you can call from console to change capacity for the current bathroom. */
  function setBathroomCapacity(loc, n){
    const map = loadBathCapMap();
    map[String(loc||'').toLowerCase()] = Math.max(1, Number(n)||BATHROOM_CAPACITY_DEFAULT);
    saveBathCapMap(map);
  }
  
  function renderBathList(){
    const bathPanel = document.getElementById('bathPanel');
    const bathBody  = document.getElementById('bathBody');
    const titleEl   = document.getElementById('bathPanelTitle');
    const loc = getLocation();
  
    const show = isBathroomLocation(loc);
    bathPanel.style.display = show ? '' : 'none';
    if (!show) return;
  
    const cap = getBathroomCapacity(loc);
    if (titleEl) titleEl.textContent = `Currently IN ‚Äî ${loc} (cap ${cap})`;
  
    const rows = getBathSet();
    bathBody.innerHTML = rows.map(r => {
      const when = new Date(r.sinceISO);
      return `<tr>
        <td class="name">${esc(r.name || '‚Äî')}</td>
        <td class="code">${esc(r.osis || '')}</td>
        <td>${fmtTime(when)}</td>
        <td>${rows.length}/${cap}</td>
      </tr>`;
    }).join('');
  }
  
  // Optional: quick ‚Äúrefresh‚Äù button keeps parity with your other panel
  document.getElementById('bathRefreshBtn')?.addEventListener('click', ()=>{
    renderBathList();
    setStatus('Bathroom list refreshed');
    setTimeout(()=> setStatus('Ready. Scan a card‚Ä¶'), 900);
  });


  /************** Audio (bad beep) **************/
  let AUDIO_CTX;
  function getAudioCtx(){
    if (!AUDIO_CTX) AUDIO_CTX = new (window.AudioContext || window.webkitAudioContext)();
    if (AUDIO_CTX.state === 'suspended') AUDIO_CTX.resume().catch(()=>{});
    return AUDIO_CTX;
  }
  ['pointerdown','keydown'].forEach(evt =>
    window.addEventListener(evt, ()=>getAudioCtx(), { once:true })
  );

  function beepPattern(pattern){ pattern.forEach(p => beepOnce(p)); }
  function beepOnce({freq=440, dur=0.2, when=0}){
    const ctx = getAudioCtx(); const t = ctx.currentTime + when;
    const osc = ctx.createOscillator(); const g = ctx.createGain();
    osc.type = 'square'; osc.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.2, t+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    osc.connect(g).connect(ctx.destination);
    osc.start(t); osc.stop(t+dur+0.05);
  }
  function beepBad(){
    beepPattern([
      { freq: 260, dur: 0.51, when: 0.00 },
      { freq: 220, dur: 0.51, when: 0.10 },
      { freq: 260, dur: 0.51, when: 0.20 },
      { freq: 220, dur: 0.51, when: 0.30 }
    ]);
  }

  /************** Header tweak for Lunch **************/
  const historyHeaderCells = document.querySelectorAll('#historyTbl thead th');
  function updateHeaderForLocation(){
    const loc = getLocation();
    const col = historyHeaderCells[2];
    if (!col) return;
  
    if (String(loc||'').toLowerCase() === SPECIAL_LOCATION.toLowerCase() || isBathroomLocation(loc)) {
      col.textContent = 'In/Out';
    } else if (isLunchLocation(loc)) {
      col.textContent = 'Allowed?';
    } else {
      col.textContent = 'Locker';
    }
  
    // Also (re)render OUT list panel visibility
    renderOutList();
    renderBathList();
    updateHistoryPaneForLocation();
    trimHistory(); // re-trim to new visible count immediately
  }

  /************** Normalization **************/
  function normalizeForLookup(raw) {
    const s = String(raw || '').trim();
    if (!/^\d+$/.test(s)) return { ok:false, reason:'non_digit', norm:'' };
    const norm = s.replace(/^0+/, '');
    if (!norm) return { ok:false, reason:'all_zeros', norm:'' };
    return { ok:true, norm };
  }

  /************** API **************/
  async function apiLookup(code){
    const body = new URLSearchParams({ action:'lookup', code });
    const wakeTimer = setTimeout(() => setStatus('Waking server‚Ä¶'), 800);
    const controller = new AbortController();
    const abortTimer = setTimeout(() => controller.abort(), 8000);
    try {
      const r = await fetch(API_BASE, { method:'POST', body, signal: controller.signal });
      const ct = r.headers.get('content-type') || '';
      const text = await r.text();
      if (!r.ok) throw new Error(`HTTP ${r.status} ${text.slice(0,120)}`);
      if (!ct.includes('application/json')) throw new Error('Upstream HTML (not JSON): ' + text.slice(0,120));
      return JSON.parse(text);
    } finally {
      clearTimeout(wakeTimer); clearTimeout(abortTimer);
      if (statusEl.textContent.includes('Waking server')) setStatus('Ready.');
    }
  }
  function makeLogId({ whenISO, code }) {
    return `${whenISO}|${code}|${getLocation()||''}|${DEVICE_ID}`;
  }
  async function apiLog(entry){
    const whenISO = entry.whenISO || new Date().toISOString();
    const log_id = makeLogId({ whenISO, code: entry.code || '' });
    const body = new URLSearchParams({
      action:'log',
      log_id,
      whenISO,
      code: entry.code || '',
      source: entry.source || 'pwa',
      resolved_name:  entry.resolved?.name  || '',
      resolved_osis:  entry.resolved?.osis  || '',
      resolved_lnum:  entry.resolved?.locker_number || '',
      resolved_lcol:  entry.resolved?.locker_color  || '',
      location: getLocation() || '',
      device_id: DEVICE_ID,
      allowed: entry.allowed || ''                // üëà add this line
    });
    try { await fetch(API_BASE, { method:'POST', body }); } catch {}
  }

  async function apiGetLocations(){
    // Try Worker first; if it fails, return static list.
    try{
      const r = await fetch(API_BASE, { method:'POST', body: new URLSearchParams({ action:'locations' }) });
      const ct = r.headers.get('content-type')||''; const text = await r.text();
      if (r.ok && ct.includes('application/json')) {
        const data = JSON.parse(text);
        if (data && data.ok && Array.isArray(data.locations)) return data.locations;
      }
    } catch(_){}
    return STATIC_LOCATIONS;
  }

  async function checkDeviceLock(){
    try{
      const r = await fetch(API_BASE, {
        method:'POST',
        body: new URLSearchParams({ action:'device_location', device_id: DEVICE_ID })
      });
      const ct = r.headers.get('content-type')||'';
      if (!r.ok || !ct.includes('application/json')) return;
      const data = await r.json();
      if (data.ok && data.locked && data.location) {
        IS_LOCATION_LOCKED = true;
        setLocation(data.location);
      }
    } catch(_) {}
  }
  
  // attach after DOM is ready (you‚Äôre already at end of body, so this is fine)
  document.getElementById('refreshRosterBtn')?.addEventListener('click', async (e)=>{
    const btn = e.currentTarget;
    btn.disabled = true;
    const original = btn.textContent;
    btn.textContent = 'Refreshing‚Ä¶';
    setUpdating(true);
    try {
      const res = await apiRefreshRoster();
      // Optional: toast in status line with counts
      setStatus(`Roster updated ‚Äî ${res?.counts?.osis ?? '?'} students`);
    } catch (err) {
      setStatus(`Update failed ‚Äî ${err.message || err}`);
    } finally {
      setTimeout(()=> setStatus('Ready. Scan a card‚Ä¶'), 1200);
      btn.textContent = original;
      btn.disabled = false;
    }
  });

  let IS_REFRESHING = false;

  async function apiRefreshRoster(){
    IS_REFRESHING = true;
    try {
      const r = await fetch(API_BASE, { method:'POST', body:new URLSearchParams({action:'refresh_mem'}) });
      const data = await r.json();
      return data;
    } finally {
      IS_REFRESHING = false;
    }
  }

  /************** Queue **************/
  function loadQueue(){ try{ return JSON.parse(localStorage.getItem(QUEUE_KEY)||'[]'); }catch{return [];} }
  function saveQueue(q){ localStorage.setItem(QUEUE_KEY, JSON.stringify(q)); }
  async function flushQueue(){
    if (!navigator.onLine) return;
    const q = loadQueue(); if (!q.length) return;
    const remain = [];
    for (const item of q){
      try{
        const res = await apiLookup(item.code); // item.code already normalized
        if (res.found){
          updateRowToSuccess(item.rowRef ?? pushPendingRow(item.seq, item.code, new Date(item.whenISO)), {
            name: res.name, code: item.code,
            lockerNum: res.locker_number, lockerColor: res.locker_color,
            when: new Date(item.whenISO)
          });
          apiLog({ whenISO:item.whenISO, code:item.code, source:'pwa', resolved:res });
        } else {
          updateRowToNotFound(item.rowRef ?? pushPendingRow(item.seq, item.code, new Date(item.whenISO)),
            item.code, new Date(item.whenISO), res.error, res.reason);
        }
      } catch { remain.push(item); }
    }
    saveQueue(remain);
  }
  window.addEventListener('online', flushQueue);
  flushQueue();

  /************** Utils **************/
  function setStatus(t){ statusEl.textContent = t; }
  function esc(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function fmtTime(d){ try{ return new Intl.DateTimeFormat(undefined,{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false}).format(d);}catch{return d.toLocaleString();} }

  /************** Scan flow **************/
  let scanSeq = 0;

  function onScan(scanned){
    // Pause scans while refreshing Worker memory
    if (IS_REFRESHING) { 
      beepBad(); 
      setStatus('Updating roster‚Ä¶ wait‚Ä¶'); 
      return; 
    }
  
    const when = new Date();
  
    // Normalize input (digits only, strip leading zeros)
    const v = normalizeForLookup(scanned);
    if (!v.ok){
      beepBad();
      const msg = v.reason === 'non_digit' ? 'Digits only' : 'All zeros is not valid';
      resultEl.innerHTML =
        `<div class="err">${esc(msg)}</div>
         <div class="code">${esc(scanned)}</div>
         <div class="muted">${fmtTime(when)}</div>`;
      setStatus('Ready.');
      return;
    }
  
    const code = v.norm;
    const row  = pushPendingRow(Date.now(), code, when);
  
    // Offline ‚Üí queue and bail
    if (!navigator.onLine){
      markRowQueued(row);
      const q = loadQueue(); 
      q.push({ seq: Date.now(), code, whenISO: when.toISOString() }); 
      saveQueue(q);
      setStatus('Offline ‚Äî queued');
      return;
    }
  
    (async () => {
      try {
        const res = await apiLookup(code);
  
        if (!res.found){
          updateRowToNotFound(row, code, when, res.error, res.reason);
          showNotFound(code, when, res.error, res.reason);
          return;
        }
  
        // Stash last-known lunch value & senior allowance for renderers
        window.__lastLunchValue   = res.lunch || '';
        window.__lastAllowedSenior = !!res.allowed_senior;
  
        const loc     = getLocation() || '';
        const whenISO = when.toISOString();
  
        // === Special: Senior Lunch (out-in) toggle ===
        if (loc.toLowerCase() === SPECIAL_LOCATION.toLowerCase()){
          const osis           = String(res.osis || '').trim();
          const allowedSenior  = !!res.allowed_senior;
          const wasOut         = isOutNow(osis);
  
          if (!allowedSenior){
            // Not allowed ‚Üí red pill ‚ÄúNOT ALLOWED‚Äù, no toggle
            updateRowToSuccess(row, { name: res.name, code, lockerNum: 'NOT ALLOWED', lockerColor: '', when });
            showSuccess(res.name, code, 'NOT ALLOWED', '', when);
            beepBad();
            // Log
            apiLog({
              whenISO, code, source:'pwa', resolved:res, allowed:'not_allowed'
            });
            setStatus('Ready. Scan next card‚Ä¶');
            return;
          }
  
          // Allowed seniors ‚Üí toggle OUT/IN and render pills (no row coloring)
          if (wasOut) removeOut(osis); else addOut(osis, res.name || '', when);
          renderOutList();
  
          const statusText = wasOut ? 'IN' : 'OUT';
          updateRowToSuccess(row, { name: res.name, code, lockerNum: statusText, lockerColor: '', when });
          showSuccess(res.name, code, statusText, '', when);
  
          // Log OUT/IN event
          apiLog({
            whenISO, code, source:'pwa', resolved:res, allowed: (wasOut ? 'in' : 'out')
          });
  
          setStatus('Ready. Scan next card‚Ä¶');
          return;
        }

         // === Special: Bathroom IN/OUT with capacity ===
         if (isBathroomLocation(loc)) {
           const osis = String(res.osis || '').trim();
           const wasIn = isInBathroom(osis);
           const cap   = getBathroomCapacity(loc);
           const list  = getBathSet();
        
           if (wasIn) {
             // Toggle OUT
             removeFromBathroom(osis);
             renderBathList();
             updateRowToSuccess(row, { name: res.name, code, lockerNum: 'OUT', lockerColor: '', when }); // row shows IN/OUT in 3rd col
             showSuccess(res.name, code, 'OUT', '', when);  // panel says OUT
             apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:'out' });
             setStatus('Ready. Scan next card‚Ä¶');
             return;
           } else {
             // Want to go IN ‚Äî check capacity
             if (list.length >= cap) {
               // Deny entry
               beepBad();
               updateRowToSuccess(row, { name: res.name, code, lockerNum: 'NOT ALLOWED', lockerColor: '', when });
               showSuccess(res.name, code, 'NOT ALLOWED', '', when);
               apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:'full' });
               setStatus(`Capacity full (${list.length}/${cap}) ‚Äî please wait`);
               return;
             }
             // Allow IN
             addInBathroom(osis, res.name || '', when);
             renderBathList();
             updateRowToSuccess(row, { name: res.name, code, lockerNum: 'IN', lockerColor: '', when }); // row shows IN/OUT in 3rd col
             showSuccess(res.name, code, 'IN', '', when); // panel says OUT/IN label; for bathroom we show IN to mean "just entered"?
             apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:'in' });
             setStatus('Ready. Scan next card‚Ä¶');
             return;
           }
         }
  
        // === Normal paths (non-senior-out-in) ===
        const isLunch = isLunchLocation(loc);
         if (isLunch){
           const allowed = isAllowedForLunch(loc, res.lunch || '');
           updateRowToSuccess(row, {
             name: res.name, code, lockerNum: '', lockerColor: '',
             lunchValue: res.lunch || '',       // üëà pass it
             when
           });
          showSuccess(res.name, code, '', '', when);
          if (!allowed) beepBad();
  
          // Log lunch gate decision
          apiLog({
            whenISO, code, source:'pwa', resolved:res, allowed: String(allowed)
          });
          setStatus('Ready. Scan next card‚Ä¶');
          return;
        }
  
        // Default (locker info)
        updateRowToSuccess(row, {
          name: res.name, code,
          lockerNum: res.locker_number, lockerColor: res.locker_color, when
        });
        showSuccess(res.name, code, res.locker_number, res.locker_color, when);
  
        // Fire-and-forget log
        apiLog({
          whenISO, code, source:'pwa', resolved:res, allowed:''
        });
  
        setStatus('Ready. Scan next card‚Ä¶');
  
      } catch (err) {
        // If it was a fetch abort or we lost connectivity mid-flight ‚Üí queue
        if (!navigator.onLine || err.name === 'AbortError'){
          markRowQueued(row);
          const q = loadQueue(); 
          q.push({ seq: Date.now(), code, whenISO: when.toISOString() }); 
          saveQueue(q);
          setStatus('Offline ‚Äî queued');
          resultEl.innerHTML =
            `<div class="err">Queued (offline)</div>
             <div class="code">${esc(code)}</div>
             <div class="muted">${fmtTime(when)}</div>`;
        } else {
          updateRowToError(row, code, when, err);
          showError(err, code, when);
        }
      }
    })();
  }

  function markRowQueued(tr){
    const first = tr.querySelector('.name');
    if (first) first.innerHTML = '<span class="queued">Queued (offline)</span>';
  }

  function showSuccess(name, code, lockerNum, lockerColor, when){
    const loc = getLocation();
  
    // Senior Lunch (out-in): only the "OUT" pill is red, add "Allowed" checkbox if applicable
    if (String(loc||'').toLowerCase() === SPECIAL_LOCATION.toLowerCase() || isBathroomLocation(loc)) {
      const label = String(lockerNum||'').toUpperCase(); // 'OUT' | 'IN' | 'NOT ALLOWED'
      const isOut = label === 'OUT';
      const isIn  = label === 'IN';
      const isNA  = label === 'NOT ALLOWED';
  
      // If we just evaluated eligibility earlier, stash it on window
      const canGoOut = !!window.__lastAllowedSenior;
  
      const pill = isOut
        ? `<span class="badge badge--out">OUT</span>`
        : (isIn ? `<span class="badge badge--in">IN</span>`
                : `<span class="badge badge--na">NOT ALLOWED</span>`);
  
      // Checkbox only when allowed seniors (not for NOT ALLOWED)
      const allowBox = (canGoOut && !isNA)
        ? `<label class="flag"><input type="checkbox" checked disabled> Allowed to go out</label>`
        : '';
  
      resultEl.innerHTML =
        `<div class="ok">OK</div>
         <div class="name">${esc(name || 'Unknown')}</div>
         <div class="code">${esc(code)} ‚Äî ${pill} ${allowBox}</div>
         <div class="muted">${fmtTime(when)}</div>`;
      setStatus('Ready. Scan next card‚Ä¶');
      return;
    }
  
    // Normal (non-Senior-Out) paths
    const allowed = (isLunchLocation(loc) ? isAllowedForLunch(loc, window.__lastLunchValue||'') : null);
    let extra = `Locker ${esc(lockerNum || '‚Äî')} (${esc(lockerColor || '‚Äî')})`;
    if (isLunchLocation(loc)) {
      extra = allowed ? `<span class="allowed-badge">Allowed</span>` : `<span class="not-allowed-badge">Not allowed</span>`;
    }
  
    resultEl.innerHTML =
      `<div class="ok">OK</div>
       <div class="name">${esc(name || 'Unknown')}</div>
       <div class="code">${esc(code)} ‚Äî ${extra}</div>
       <div class="muted">${fmtTime(when)}</div>`;
    setStatus('Ready. Scan next card‚Ä¶');
  }

  function showNotFound(code, when){
    beepBad();
    resultEl.innerHTML =
      `<div class="err">Not found</div>
       <div class="code">${esc(code)}</div>
       <div class="muted">${fmtTime(when)}</div>`;
    setStatus('Ready.');
  }

  function showError(err, code, when){
    beepBad();
    resultEl.innerHTML =
      `<div class="err">Lookup error</div>
       <div class="code">${esc(code||'')}</div>
       <div class="muted">${fmtTime(when)} ‚Äî ${esc(err.message||String(err))}</div>`;
    setStatus('Ready.');
  }

  function pushHistoryRow(name, code, lockerNum, lockerColor, when){
    const tr = document.createElement('tr');
    const color = String(lockerColor||'').trim();
    const num   = String(lockerNum||'').trim();
    const cssColor = ({
      red:'#e53935', blue:'#1e88e5', green:'#43a047', yellow:'#fdd835',
      purple:'#8e24aa', orange:'#fb8c00', pink:'#d81b60', gray:'#78909c',
      grey:'#78909c', black:'#263238', white:'#fafafa', teal:'#009688'
    })[color.toLowerCase()] || null;

    const lockerHtml = isLunchLocation(getLocation()) ? '‚Äî'
      : ((num || color)
          ? (cssColor
              ? `<span class="swatch" style="background:${cssColor}"></span>${esc(num)} <span class="muted">(${esc(color)})</span>`
              : `${esc(num)} <span class="muted">(${esc(color)})</span>`)
          : '‚Äî');

    tr.innerHTML =
      `<td class="name">${esc(name)}</td>
       <td class="code">${esc(code)}</td>
       <td>${lockerHtml}</td>
       <td>${fmtTime(when)}</td>`;
    historyBody.prepend(tr);
    trimHistory();
  }

  function pushPendingRow(seq, code, when){
    const tr = document.createElement('tr');
    tr.dataset.seq = String(seq);
    tr.innerHTML =
      `<td class="name"><em>‚Ä¶looking up‚Ä¶</em></td>
       <td class="code">${esc(code)}</td>
       <td>‚Äî</td>
       <td>${fmtTime(when)}</td>`;
    historyBody.prepend(tr);
    trimHistory();
    return tr;
  }

  function updateRowToSuccess(tr, {name, code, lockerNum, lockerColor, lunchValue, when}){
    const loc = getLocation();
  
    if (String(loc||'').toLowerCase() === SPECIAL_LOCATION.toLowerCase() || isBathroomLocation(loc)) {
      // Here lockerNum carries the status 'OUT' | 'IN' | 'NOT ALLOWED'
      const label = String(lockerNum||'').toUpperCase();
      const isOut = label === 'OUT';
      const isIn  = label === 'IN';
      const isNA  = label === 'NOT ALLOWED';
  
      const pill = isOut
        ? `<span class="badge badge--out">ü´• OUT</span>`
        : (isIn ? `<span class="badge badge--in">üòê IN</span>`
                : `<span class="badge badge--na">NOT ALLOWED</span>`);
      // Only Senior Lunch shows the "Allowed to go out" checkbox
      const canGoOut = (String(loc||'').toLowerCase() === SPECIAL_LOCATION.toLowerCase()) && !!window.__lastAllowedSenior;
      const allowBox = (canGoOut && !isNA)
       ? `<label class="flag"><input type="checkbox" checked disabled> Allowed to go out</label>`
       : '';
      
  
      tr.className = ''; // no row-level coloring
      tr.innerHTML =
        `<td class="name">${esc(name||'Unknown')}</td>
         <td class="code">${esc(code)}</td>
         <td>${pill} ${allowBox}</td>
         <td>${fmtTime(when)}</td>`;
      return;
    }

    // --- Lunch locations: replace the 3rd cell with Allowed / Not allowed ---
    if (isLunchLocation(loc)) {
      const allowed = isAllowedForLunch(loc, lunchValue ?? window.__lastLunchValue ?? '');
      const thirdCellHtml = allowed
        ? `<span class="allowed-badge">‚úÖ Allowed</span>`
        : `<span class="not-allowed-badge">‚ùå Not allowed</span>`;
  
      tr.className = '';
      tr.innerHTML =
        `<td class="name">${esc(name||'Unknown')}</td>
         <td class="code">${esc(code)}</td>
         <td>${thirdCellHtml}</td>
         <td>${fmtTime(when)}</td>`;
      return;
    }
  
    // --- Normal locations ---
    const color = (lockerColor||'').trim();
    const cssColor = ({
      red:'#e53935', blue:'#1e88e5', green:'#43a047', yellow:'#fdd835',
      purple:'#8e24aa', orange:'#fb8c00', pink:'#d81b60', gray:'#78909c',
      grey:'#78909c', black:'#263238', white:'#fafafa', teal:'#009688'
    })[color.toLowerCase()] || null;
  
    const lockerHtml = (lockerNum || color)
      ? (cssColor
          ? `<span class="swatch" style="background:${cssColor}"></span>${esc(lockerNum||'')} <span class="muted">(${esc(color)})</span>`
          : `${esc(lockerNum||'')} <span class="muted">(${esc(color)})</span>`)
      : '‚Äî';
  
    tr.className = ''; // no row-level coloring
    tr.innerHTML =
      `<td class="name">${esc(name||'Unknown')}</td>
       <td class="code">${esc(code)}</td>
       <td>${lockerHtml}</td>
       <td>${fmtTime(when)}</td>`;
  }

  function updateRowToNotFound(tr, code, when, error, reason){
    beepBad();
    const msg = error === 'invalid_input'
      ? (reason === 'leading_zero_osis' ? 'Leading-zero OSIS ‚Äî scan card.' : 'Digits only.')
      : 'Not found';
    tr.innerHTML =
      `<td class="name"><span class="bad">${esc(msg)}</span></td>
       <td class="code">${esc(code)}</td>
       <td>‚Äî</td>
       <td>${fmtTime(when)}</td>`;
  }

  function updateRowToError(tr, code, when, err){
    beepBad();
    tr.innerHTML =
      `<td class="name"><span class="bad">Lookup error</span></td>
       <td class="code">${esc(code)}</td>
       <td>‚Äî</td>
       <td>${fmtTime(when)}</td>`;
  }

  function trimHistory(){
    const maxVisible = isSeniorOutIn() ? HISTORY_VISIBLE_SENIOR : HISTORY_VISIBLE_DEFAULT;
    // keep only the top N most recent rows in the DOM
    while (historyBody.children.length > maxVisible) {
      historyBody.lastChild.remove();
    }
    // you can still keep HISTORY_MAX if you later add off-DOM storage; for now DOM == visible
  }

  /************** Keyboard wedge **************/
  window.addEventListener('keydown', (e)=>{
    if (IS_MODAL_OPEN || isModalVisible()) return;
    keepFocus();

    const now = performance.now();
    const gap = now - (lastKeyTs || now);
    lastKeyTs = now;

    if (e.key === 'Enter'){
      const finished = wedgeBuf;
      wedgeBuf = "";
      if (finished){
        e.preventDefault();
        onScan(finished);
        manualInput.value = '';
      }
      return;
    }

    if (e.key.length === 1){
      const looksLikeScanner = gap <= SCAN_GAP_MS && (wedgeBuf.length > 0 || gap > 0);
      if (looksLikeScanner){
        e.preventDefault();
        wedgeBuf += e.key;
      }
    }

    clearTimeout(wedgeResetTimer);
    wedgeResetTimer = setTimeout(()=> { wedgeBuf = ""; }, 200);
  }, true);

  /************** Manual form **************/
  document.getElementById('manualForm').addEventListener('submit', (e)=>{
    e.preventDefault();
    if (IS_MODAL_OPEN || isModalVisible()) return;
    const v = manualInput.value.trim();
    if (v) onScan(v);
    manualInput.value = '';
    keepFocus();
  });

  function keepFocus(){
    if (IS_MODAL_OPEN || isModalVisible()) return;
    if (document.activeElement !== manualInput) manualInput.focus({preventScroll:true});
    manualInput.setSelectionRange(manualInput.value.length, manualInput.value.length);
  }
  keepFocus(); setInterval(keepFocus, 1000);

/************** Battery indicator (Chromebook/Chrome) **************/
  async function initBatteryPill(){
    const pill = document.getElementById('batteryPill');
    if (!pill || !navigator.getBattery) { 
      // Hide if unsupported
      pill && (pill.style.display = 'none'); 
      return; 
    }
    try {
      const batt = await navigator.getBattery();
  
      function fmt(b){
        const pct = Math.round((b.level || 0) * 100);
        const charging = b.charging;
        // Choose an icon
        let ico = 'üîã';
        if (charging) ico = '‚ö°';
        else if (pct <= 10) ico = 'ü™´';
        else if (pct <= 30) ico = 'üîã'; // could swap for different glyphs if desired
  
        // Optional time remaining (minutes)
        let extra = '';
        if (!charging && Number.isFinite(b.dischargingTime) && b.dischargingTime > 0) {
          const mins = Math.round(b.dischargingTime / 60);
          extra = ` ‚Ä¢ ${mins}m left`;
        } else if (charging && Number.isFinite(b.chargingTime) && b.chargingTime > 0) {
          const mins = Math.round(b.chargingTime / 60);
          extra = ` ‚Ä¢ ${mins}m to full`;
        }
  
        pill.textContent = `${ico} ${pct}%${extra}`;
        // color state
        pill.classList.remove('pill--bad','pill--warn');
        if (!charging && pct <= 10) pill.classList.add('pill--bad');
        else if (!charging && pct <= 25) pill.classList.add('pill--warn');
      }
  
      fmt(batt);
      batt.addEventListener('levelchange',     ()=>fmt(batt));
      batt.addEventListener('chargingchange',  ()=>fmt(batt));
      batt.addEventListener('dischargingtimechange', ()=>fmt(batt));
      batt.addEventListener('chargingtimechange',    ()=>fmt(batt));
    } catch {
      // If anything throws, hide it quietly
      pill.style.display = 'none';
    }
  }

/************** Network indicator (no true signal bars in web) **************/
  function initNetworkPill(){
    const pill = document.getElementById('netPill');
    if (!pill) return;
  
    const navConn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
  
    function fmt(){
      // Basic online state
      const online = navigator.onLine;
  
      // Defaults
      let type = 'unknown';
      let eff  = '';
      let mbps = '';
      let rtt  = '';
  
      if (navConn) {
        // type: 'wifi' | 'ethernet' | 'cellular' | etc (may be undefined on some devices)
        type = navConn.type || (online ? 'online' : 'offline');
        // effectiveType: '4g'|'3g'|'2g'|'slow-2g'
        eff  = navConn.effectiveType ? ` ${navConn.effectiveType}` : '';
        if (typeof navConn.downlink === 'number') {
          mbps = ` ‚Ä¢ ${Math.round(navConn.downlink)} Mbps`;
        }
        if (typeof navConn.rtt === 'number' && navConn.rtt > 0) {
          rtt = ` ‚Ä¢ ${navConn.rtt} ms`;
        }
      } else {
        type = online ? 'online' : 'offline';
      }
  
      pill.classList.remove('pill--bad','pill--warn');
  
      if (!online) {
        pill.textContent = 'Offline';
        pill.classList.add('pill--bad');
        return;
      }
  
      // Heuristic coloring
      if (navConn) {
        if (navConn.effectiveType === 'slow-2g' || navConn.effectiveType === '2g') {
          pill.classList.add('pill--bad');
        } else if (navConn.effectiveType === '3g') {
          pill.classList.add('pill--warn');
        }
      }
  
      // Show ‚ÄúWi-Fi‚Äù label for type=wifi
      const label = (type === 'wifi') ? 'Wi-Fi' : (type === 'ethernet' ? 'Ethernet' : type);
      pill.textContent = `${label}${eff}${mbps}${rtt}`;
    }
  
    fmt();
  
    // Live updates
    window.addEventListener('online', fmt);
    window.addEventListener('offline', fmt);
    if (navConn && typeof navConn.addEventListener === 'function') {
      navConn.addEventListener('change', fmt);
    } else if (navConn) {
      // Older implementations use onchange
      navConn.onchange = fmt;
    }
  }

  /************** Online/offline pill + location init **************/
  function updateOnlinePill(){
    const on = navigator.onLine;
    onlinePill.textContent = on ? 'Online' : 'Offline';
    onlinePill.style.background = on ? '#eaf7ea' : '#fff3e0';
    onlinePill.style.color = on ? '#0a7c2f' : '#8a5a00';
  }
  window.addEventListener('online', updateOnlinePill);
  window.addEventListener('offline', updateOnlinePill);
  updateOnlinePill();

  function isModalVisible() {
    const m = document.getElementById('locModal');
    if (!m) return false;
    return getComputedStyle(m).display !== 'none';
  }
  function setModalOpen(v){ IS_MODAL_OPEN = !!v; }

  // Location pill UI
  function updateLocationPill(){
    const pill = document.getElementById('locationPill');
    const v = getLocation();
    pill.textContent = v ? `Location: ${v}${IS_LOCATION_LOCKED ? ' (locked)' : ''}` : 'Set location';
    pill.style.background = v ? '#e7f0fe' : '#fff3e0';
    pill.style.color = v ? '#0b57d0' : '#8a5a00';
    pill.style.cursor = IS_LOCATION_LOCKED ? 'not-allowed' : 'pointer';
    pill.title = IS_LOCATION_LOCKED ? 'This device is locked to this location' : 'Click to change location';
    updateHeaderForLocation();
  }

  async function promptForLocation(force=false){
    if (IS_LOCATION_LOCKED) { alert(`This device is locked to ${getLocation()}.`); return; }
    if (!force && getLocation()) { updateLocationPill(); return; }

    const modal = document.getElementById('locModal');
    const sel   = document.getElementById('locSelect');
    const btnOK = document.getElementById('locSaveBtn');
    const btnX  = document.getElementById('locCancelBtn');

    sel.innerHTML = `<option value="">Loading‚Ä¶</option>`;
    modal.style.display = 'flex';
    setModalOpen(true);
    manualInput.blur();
    cardEl?.setAttribute?.('inert', '');
    setTimeout(() => sel.focus({ preventScroll: true }), 0);

    try {
      const list = await apiGetLocations();
      sel.innerHTML = `<option value="">Select a location‚Ä¶</option>` + list.map(v => `<option>${esc(v)}</option>`).join('');
      const saved = getLocation(); if (saved) sel.value = saved;
    } catch {
      // Shouldn't happen with static fallback, but keep a friendly message
      sel.innerHTML = `<option value="">(Using defaults)</option>` + STATIC_LOCATIONS.map(v=>`<option>${esc(v)}</option>`).join('');
    }

    return new Promise(resolve=>{
      const close = (val) => {
        modal.style.display = 'none';
        setModalOpen(false);
        cardEl?.removeAttribute?.('inert');
        setTimeout(() => { keepFocus(); }, 0);
        resolve(val);
      };
      btnOK.onclick = () => {
        const val = sel.value.trim();
        if (val) { setLocation(val); updateHeaderForLocation(); close(val); }
        else { alert('Please choose a location.'); }
      };
      btnX.onclick = () => close(getLocation());
      modal.addEventListener('click', (ev)=>{ if (ev.target === modal) close(getLocation()); }, { once:true });
    });
  }

  // Device lock (safe if Worker doesn't implement it)
  (async () => { await checkDeviceLock(); updateLocationPill(); updateHistoryPaneForLocation(); trimHistory(); promptForLocation(false);renderBathList(); })();

  // Allow changing later
  document.getElementById('locationPill').addEventListener('click', () => {
    if (IS_LOCATION_LOCKED) { alert(`This device is locked to ${getLocation()}.`); return; }
    promptForLocation(true);
  });
  document.body.addEventListener('click', (e)=>{
    const t = e.target;
    if (t && (t.id === 'locationPill' || t.closest?.('#locationPill'))) {
      e.preventDefault();
      if (IS_LOCATION_LOCKED) { alert(`This device is locked to ${getLocation()}.`); return; }
      promptForLocation(true);
    }
  });

  /************** Wake Lock **************/
  let wakeLock = null;
  async function requestWakeLock() {
    if (!('wakeLock' in navigator)) return;
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', () => {
        if (document.visibilityState === 'visible') requestWakeLock();
      });
    } catch {}
  }
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') requestWakeLock();
  });
  window.addEventListener('focus', requestWakeLock);
  window.addEventListener('keydown', requestWakeLock, { once: true });
  window.addEventListener('pointerdown', requestWakeLock, { once: true });

  initBatteryPill();
  initNetworkPill();

  </script>
</body>
</html>
