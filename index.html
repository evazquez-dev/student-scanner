<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Student Scanner</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest" />
  <meta name="theme-color" content="#0b57d0" />
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(()=>{});
    }
  </script>

  <style>
    :root { --fg:#0b1320; --muted:#5e6b7a; --brand:#0b57d0; --bg:#f6f8fb; }
    html,body { height:100%; }
    body {
      margin:0; font:16px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:var(--fg); background:var(--bg);
      display:flex; align-items:center; justify-content:center; min-height:100dvh;
    }
    .card {
      width:min(920px, 96vw); background:#fff; border-radius:18px; padding:20px 20px 16px;
      box-shadow:0 10px 30px rgba(0,0,0,.06);
    }
    h1 { margin:0 0 4px 0; font-size:22px; }
    .muted { color:var(--muted); font-size:13px; }
    .row { display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap; }
    .col { flex:1 1 320px; }
    .panel {
      background:#fafbff; border:1px solid #eef1f7; border-radius:14px; padding:14px;
    }
    #status { font-weight:600; }
    #result { font-size:17px; margin-top:6px; }
    table { width:100%; border-collapse:collapse; font-size:14px; }
    th,td { padding:8px 6px; border-bottom:1px solid #edf1f6; text-align:left; }
    th { font-weight:600; color:#667; background:#f8f9fc; }
    .ok { color:#0a7c2f; font-weight:600; }
    .err { color:#b00020; font-weight:600; }
    .name { font-weight:700; }
    .code { color:#556; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .input-wrap { display:flex; gap:8px; align-items:center; }
    input[type=text] {
      flex:1; padding:10px 12px; font-size:18px; border-radius:12px; border:1px solid #cfd7e3; outline:none;
    }
    .swatch{display:inline-block;width:10px;height:10px;border-radius:50%;vertical-align:middle;margin-right:6px;border:1px solid #ccd3de}
    button {
      cursor:pointer; border:none; border-radius:12px; padding:10px 14px; font-weight:600; background:var(--brand); color:#fff;
    }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eaf7ea; color:#0a7c2f; font-size:12px; }
    .scans-pane{
      max-height: 360px;     /* ~10 rows */
      overflow-y: auto;
      border: 1px solid #e5e9f2;
      border-radius: 8px;
      background: #fff;
    }
    /* keep header visible while scrolling */
    .scans-pane thead th{
      position: sticky;
      top: 0;
      background: #f7f9fc;
      z-index: 1;
      box-shadow: 0 1px 0 rgba(0,0,0,0.06);
    }
    /* slightly tighter table so 10 fit nicely */
    #historyTbl td, #historyTbl th{ padding: 8px 10px; line-height: 1.2; }
    .bad { color:#b00020; font-weight:600; }
    .queued { color:#8a5a00; font-weight:600; }

    /* Lunch UI */
    .not-allowed-row { background:#fdecea; } /* soft red */
    .allowed-badge { color:#0a7c2f; font-weight:700; }
    .not-allowed-badge { color:#b00020; font-weight:700; }

    /* Modal topmost + inert safety */
    #locModal { position:fixed; inset:0; z-index: 2147483000; }
    .card[inert] { pointer-events: none; }
  </style>
</head>
<body>
  <div id="locModal" style="background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center;">
    <div style="background:#fff; width:min(360px, 92vw); border-radius:14px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.2)">
      <div style="font-weight:700; margin-bottom:8px;">Select your location</div>
      <div class="muted" style="margin-bottom:12px">This will be saved and attached to each scan.</div>
      <select id="locSelect" style="width:100%; padding:10px; border:1px solid #cfd7e3; border-radius:10px; margin-bottom:12px">
        <option value="">Loading…</option>
      </select>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="locCancelBtn" style="background:#e5e9f2; color:#333">Cancel</button>
        <button id="locSaveBtn">Save</button>
      </div>
    </div>
  </div>

  <div class="card">
    <h1>Student Scanner 
      <span class="pill" id="onlinePill">Online</span>
      <span class="pill" id="locationPill" style="margin-left:6px; cursor:pointer;" title="Click to change location">Set location</span>
    </h1>
    <div class="muted">RFID keyboard-wedge or keypad: enter OSIS/RFID + Enter. Shows Name, Locker #/Color, and scan time.</div>

    <div class="row" style="margin-top:14px">
      <!-- Left: Live status + last result + manual entry -->
      <div class="col">
        <div class="panel">
          <div id="status">Ready. Scan a card…</div>
          <div id="result"></div>

          <hr style="border:none;border-top:1px solid #edf1f6; margin:12px -14px" />

          <div class="muted" style="margin-bottom:6px">Manual entry (keypad or typing):</div>
          <form id="manualForm" class="input-wrap" autocomplete="off">
            <input id="manualInput" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="Type OSIS or RFID and press Enter" />
            <button type="submit">Enter</button>
          </form>
          <div class="muted" style="margin-top:6px">Tip: The field keeps focus—good for external keypads.</div>
        </div>
      </div>

      <!-- Right: Recent scans -->
      <div class="col">
        <div class="panel">
          <div class="muted" style="margin-bottom:8px">Recent scans (local)</div>
          <div id="scansPane" class="scans-pane">
            <table id="historyTbl" aria-label="Scan history">
              <thead>
                <tr>
                  <th style="width:30%">Name</th>
                  <th style="width:20%">Code</th>
                  <th style="width:22%">Locker</th>
                  <th style="width:28%">Time</th>
                </tr>
              </thead>
              <tbody id="historyBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="muted" style="margin-top:10px">
      Configure <span class="code">API_BASE</span> in the script below.
    </div>
  </div>

  <script>
  /**************** CONFIG — EDIT ME ****************/
  // Worker URL (not GAS): it should forward lookup/log/locations to GAS
  const API_BASE = 'https://red-cake-77d5.evazquez-3e0.workers.dev/';
  (async () => {
    try {
      await fetch(API_BASE, { method: 'POST', body: new URLSearchParams({ action: 'ping' }) });
    } catch (_) {}
  })();

  // Keyboard-wedge behavior
  const STRIP_PREFIX = true;
  const SCAN_CHAR_MS = 30;        // max ms between chars to treat input as "scanner"
  const DEDUPE_MS = 1000;
  const HISTORY_VISIBLE = 10;     // ~10 rows visible in the pane
  const HISTORY_MAX = 1000;       // keep up to 1000 rows in memory for scrolling

  /**************** STATE + DOM ****************/
  let buffer = "", lastTs = 0, resetTimer = null;
  let lastScanValue = "", lastScanAt = 0;
  let IS_MODAL_OPEN = false;

  const statusEl = document.getElementById('status');
  const resultEl = document.getElementById('result');
  const historyBody = document.getElementById('historyBody');
  const manualInput = document.getElementById('manualInput');
  const onlinePill = document.getElementById('onlinePill');
  const locationPill = document.getElementById('locationPill');
  const cardEl = document.querySelector('.card');

  const QUEUE_KEY = 'scanQueueV1';
  const LOC_KEY = 'scannerLocationV1';

  function getLocation(){ return localStorage.getItem(LOC_KEY) || ''; }
  function setLocation(v){ localStorage.setItem(LOC_KEY, v || ''); updateLocationPill(); }

  /**************** Lunch helpers ****************/
  function isLunchLocation(loc){
    const v = String(loc||'').toLowerCase().trim();
    return v === 'lunch' || v === 'lunch 1' || v === 'lunch 2';
  }
  function lunchSlotFromLocation(loc){
    const v = String(loc||'').toLowerCase();
    return v.includes('2') ? 2 : 1; // default 1 when plain "Lunch"
  }
  function normalizeLunchValue(s){
    // Accept "1", "2", "Lunch 1", "Lunch2", "L1", "Group 1", etc.
    const v = String(s||'').toLowerCase().replace(/\s+/g,'').replace('lunch','').replace('group','').replace('l','');
    const m = v.match(/([12])/);
    return m ? Number(m[1]) : null;
  }
  function isAllowedForLunch(location, lunchValue){
    const need = lunchSlotFromLocation(location);
    const have = normalizeLunchValue(lunchValue);
    return have === need;
  }

  /**************** Header toggle (Locker ⇄ Allowed?) ****************/
  const historyHeaderCells = document.querySelectorAll('#historyTbl thead th');
  function updateHeaderForLocation(){
    const loc = getLocation();
    if (isLunchLocation(loc)) {
      if (historyHeaderCells[2]) historyHeaderCells[2].textContent = 'Allowed?';
    } else {
      if (historyHeaderCells[2]) historyHeaderCells[2].textContent = 'Locker';
    }
  }

  /**************** Modal + locations ****************/
  async function apiGetLocations(){
    const r = await fetch(API_BASE, { method:'POST', body: new URLSearchParams({ action:'locations' }) });
    const ct = r.headers.get('content-type')||'';
    const text = await r.text();
    if (!r.ok) throw new Error(`HTTP ${r.status} ${text.slice(0,120)}`);
    if (!ct.includes('application/json')) throw new Error('Bad content-type for locations');
    const data = JSON.parse(text);
    if (!data.ok) throw new Error(data.error || 'locations_error');
    return data.locations || [];
  }

  async function promptForLocation(force=false){
    if (!force && getLocation()) { updateLocationPill(); return; }

    const modal = document.getElementById('locModal');
    const sel   = document.getElementById('locSelect');
    const btnOK = document.getElementById('locSaveBtn');
    const btnX  = document.getElementById('locCancelBtn');

    // Open first, then fetch
    sel.innerHTML = `<option value="">Loading…</option>`;
    modal.style.display = 'flex';
    setModalOpen(true);
    manualInput.blur();
    cardEl?.setAttribute?.('inert', '');
    setTimeout(() => sel.focus({ preventScroll: true }), 0);

    try {
      const list = await apiGetLocations();
      sel.innerHTML = `<option value="">Select a location…</option>` + list.map(v => `<option>${esc(v)}</option>`).join('');
      const saved = getLocation();
      if (saved) sel.value = saved;
    } catch (e) {
      sel.innerHTML = `<option value="">(Couldn’t load locations)</option>`;
    }

    return new Promise(resolve=>{
      const close = (val) => {
        modal.style.display = 'none';
        setModalOpen(false);
        cardEl?.removeAttribute?.('inert');
        setTimeout(() => { keepFocus(); }, 0);
        resolve(val);
      };
      btnOK.onclick = () => {
        const val = sel.value.trim();
        if (val) { setLocation(val); updateHeaderForLocation(); close(val); }
        else { alert('Please choose a location.'); }
      };
      btnX.onclick = () => close(getLocation());
      modal.addEventListener('click', (ev)=>{ if (ev.target === modal) close(getLocation()); }, { once:true });
    });
  }

  function updateLocationPill(){
    const pill = document.getElementById('locationPill');
    const v = getLocation();
    pill.textContent = v ? `Location: ${v}` : 'Set location';
    pill.style.background = v ? '#e7f0fe' : '#fff3e0';
    pill.style.color = v ? '#0b57d0' : '#8a5a00';
    updateHeaderForLocation();
  }

  function isModalVisible() {
    const m = document.getElementById('locModal');
    if (!m) return false;
    return getComputedStyle(m).display !== 'none';
  }
  function setModalOpen(v){ IS_MODAL_OPEN = !!v; }

  /**************** Offline queue ****************/
  function loadQueue(){ try{ return JSON.parse(localStorage.getItem(QUEUE_KEY)||'[]'); }catch{return [];} }
  function saveQueue(q){ localStorage.setItem(QUEUE_KEY, JSON.stringify(q)); }
  async function flushQueue(){
    if (!navigator.onLine) return;
    const q = loadQueue();
    if (!q.length) return;
    const remain = [];
    for (const item of q){
      try{
        const res = await apiLookup(item.code);
        if (res.found){
          updateRowToSuccess(item.rowRef ?? pushPendingRow(item.seq, item.code, new Date(item.whenISO)), {
            name: res.name, code: item.code,
            lockerNum: res.locker_number, lockerColor: res.locker_color,
            when: new Date(item.whenISO)
          });
          apiLog({ whenISO:item.whenISO, code:item.code, source:'pwa', resolved:res });
        } else {
          updateRowToNotFound(item.rowRef ?? pushPendingRow(item.seq, item.code, new Date(item.whenISO)),
            item.code, new Date(item.whenISO), res.error, res.reason);
        }
      } catch {
        remain.push(item);
      }
    }
    saveQueue(remain);
  }
  window.addEventListener('online', flushQueue);
  flushQueue();

  /**************** Utils ****************/
  function setStatus(t){ statusEl.textContent = t; }
  function vibrate(){ try{ navigator.vibrate?.(30); }catch{} }
  function esc(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function fmtTime(d){ try{ return new Intl.DateTimeFormat(undefined,{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false}).format(d);}catch{return d.toLocaleString();} }

  /**************** API ****************/
  async function apiLookup(code){
    const body = new URLSearchParams({ action:'lookup', code });
    const wakeTimer = setTimeout(() => setStatus('Waking server…'), 700);
    const controller = new AbortController();
    const abortTimer = setTimeout(() => controller.abort(), 8000);
    try {
      const r = await fetch(API_BASE, { method:'POST', body, signal: controller.signal });
      const ct = r.headers.get('content-type') || '';
      const text = await r.text();
      if (!r.ok) throw new Error(`HTTP ${r.status} ${text.slice(0,120)}`);
      if (!ct.includes('application/json')) throw new Error('Upstream HTML (not JSON): ' + text.slice(0,120));
      return JSON.parse(text);
    } finally {
      clearTimeout(wakeTimer);
      clearTimeout(abortTimer);
      if (statusEl.textContent.includes('Waking server')) setStatus('Ready.');
    }
  }
  function makeLogId({ whenISO, code }) {
    return `${whenISO}|${code}|${getLocation()||''}|${DEVICE_ID}`;
  }
  const DEVICE_ID = (localStorage.getItem('scannerDeviceId') ||
    (localStorage.setItem('scannerDeviceId', crypto.randomUUID()), localStorage.getItem('scannerDeviceId')));
  async function apiLog(entry){
    const whenISO = entry.whenISO || new Date().toISOString();
    const log_id = makeLogId({ whenISO, code: entry.code || '' });
    const body = new URLSearchParams({
      action:'log',
      log_id,
      whenISO,
      code: entry.code || '',
      source: entry.source || 'pwa',
      resolved_name:  entry.resolved?.name  || '',
      resolved_osis:  entry.resolved?.osis  || '',
      resolved_lnum:  entry.resolved?.locker_number || '',
      resolved_lcol:  entry.resolved?.locker_color  || '',
      location: getLocation() || '',
      device_id: DEVICE_ID
    });
    try { await fetch(API_BASE, { method:'POST', body }); } catch {}
  }

  /**************** SCAN FLOW ****************/
  let scanSeq = 0;

  function onScan(code){
    const when = new Date();
    const seq = ++scanSeq;
    const row = pushPendingRow(seq, code, when);

    if (!navigator.onLine){
      markRowQueued(row);
      const q = loadQueue(); q.push({ seq, code, whenISO: when.toISOString() }); saveQueue(q);
      setStatus('Offline — queued');
      return;
    }

    void (async () => {
      try {
        const res = await apiLookup(code);
        if (res.found) {
          window.__lastLunchValue = res.lunch || '';
          updateRowToSuccess(row, { name: res.name, code, lockerNum: res.locker_number, lockerColor: res.locker_color, when });
          apiLog({
            whenISO: when.toISOString(),
            code, source: 'pwa', resolved: res,
            allowed: (isLunchLocation(getLocation()) ? String(isAllowedForLunch(getLocation(), res.lunch||'')) : '')
          });
        } else {
          updateRowToNotFound(row, code, when, res.error, res.reason);
        }
      } catch (err) {
        if (!navigator.onLine || (err.name === 'AbortError')){
          markRowQueued(row);
          const q = loadQueue(); q.push({ seq, code, whenISO: when.toISOString() }); saveQueue(q);
          setStatus('Offline — queued');
        } else {
          updateRowToError(row, code, when, err);
        }
      }
    })();
  }

  function markRowQueued(tr){
    const first = tr.querySelector('.name');
    if (first) first.innerHTML = '<span class="queued">Queued (offline)</span>';
  }

  function showSuccess(name, code, lockerNum, lockerColor, when){
    const loc = getLocation();
    let extra = `Locker ${esc(lockerNum || '—')} (${esc(lockerColor || '—')})`;
    if (isLunchLocation(loc)) {
      const allowed = isAllowedForLunch(loc, window.__lastLunchValue||'');
      extra = allowed
        ? `<span class="allowed-badge">Allowed</span>`
        : `<span class="not-allowed-badge">Not allowed</span>`;
    }
    resultEl.innerHTML =
      `<div class="ok">OK</div>
       <div class="name">${esc(name || 'Unknown')}</div>
       <div class="code">${esc(code)} — ${extra}</div>
       <div class="muted">${fmtTime(when)}</div>`;
    pushHistoryRow(name || 'Unknown', code, lockerNum, lockerColor, when);
    setStatus('Ready. Scan next card…');
  }

  function showNotFound(code, when){
    resultEl.innerHTML =
      `<div class="err">Not found</div>
       <div class="code">${esc(code)}</div>
       <div class="muted">${fmtTime(when)}</div>`;
    setStatus('Ready.');
  }

  function showError(err, code, when){
    resultEl.innerHTML =
      `<div class="err">Lookup error</div>
       <div class="code">${esc(code||'')}</div>
       <div class="muted">${fmtTime(when)} — ${esc(err.message||String(err))}</div>`;
    setStatus('Ready.');
  }

  function pushHistoryRow(name, code, lockerNum, lockerColor, when){
    const tr = document.createElement('tr');
    const color = String(lockerColor||'').trim();
    const num   = String(lockerNum||'').trim();

    const cssColor = ({
      red:'#e53935', blue:'#1e88e5', green:'#43a047', yellow:'#fdd835',
      purple:'#8e24aa', orange:'#fb8c00', pink:'#d81b60', gray:'#78909c',
      grey:'#78909c', black:'#263238', white:'#fafafa', teal:'#009688'
    })[color.toLowerCase()] || null;

    const lockerHtml = isLunchLocation(getLocation())
      ? '—'
      : ((num || color)
          ? (cssColor
              ? `<span class="swatch" style="background:${cssColor}"></span>${esc(num)} <span class="muted">(${esc(color)})</span>`
              : `${esc(num)} <span class="muted">(${esc(color)})</span>`)
          : '—');

    tr.innerHTML =
      `<td class="name">${esc(name)}</td>
       <td class="code">${esc(code)}</td>
       <td>${lockerHtml}</td>
       <td>${fmtTime(when)}</td>`;
    historyBody.prepend(tr);
    trimHistory();
  }

  function pushPendingRow(seq, code, when){
    const tr = document.createElement('tr');
    tr.dataset.seq = String(seq);
    tr.innerHTML =
      `<td class="name"><em>…looking up…</em></td>
       <td class="code">${esc(code)}</td>
       <td>—</td>
       <td>${fmtTime(when)}</td>`;
    historyBody.prepend(tr);
    trimHistory();
    return tr;
  }

  function updateRowToSuccess(tr, {name, code, lockerNum, lockerColor, when}){
    const color = (lockerColor||'').trim();
    const cssColor = ({
      red:'#e53935', blue:'#1e88e5', green:'#43a047', yellow:'#fdd835',
      purple:'#8e24aa', orange:'#fb8c00', pink:'#d81b60', gray:'#78909c',
      grey:'#78909c', black:'#263238', white:'#fafafa', teal:'#009688'
    })[color.toLowerCase()] || null;

    const loc = getLocation();
    let thirdCellHtml = '';
    let rowClass = '';

    if (isLunchLocation(loc)) {
      const allowed = isAllowedForLunch(loc, window.__lastLunchValue||'');
      thirdCellHtml = allowed
        ? `<span class="allowed-badge">✅ Allowed</span>`
        : `<span class="not-allowed-badge">❌ Not allowed</span>`;
      rowClass = allowed ? '' : 'not-allowed-row';
      if (!allowed) beepBad();
    } else {
      const lockerHtml = (lockerNum || color)
        ? (cssColor
            ? `<span class="swatch" style="background:${cssColor}"></span>${esc(lockerNum||'')} <span class="muted">(${esc(color)})</span>`
            : `${esc(lockerNum||'')} <span class="muted">(${esc(color)})</span>`)
        : '—';
      thirdCellHtml = lockerHtml;
    }

    tr.className = rowClass;
    tr.innerHTML =
      `<td class="name">${esc(name||'Unknown')}</td>
       <td class="code">${esc(code)}</td>
       <td>${thirdCellHtml}</td>
       <td>${fmtTime(when)}</td>`;
  }

  function updateRowToNotFound(tr, code, when, error, reason){
    const msg = error === 'invalid_input'
      ? (reason === 'leading_zero_osis'
          ? 'Leading-zero OSIS — scan card.'
          : 'Digits only.')
      : 'Not found';
    tr.innerHTML =
      `<td class="name"><span class="bad">${esc(msg)}</span></td>
       <td class="code">${esc(code)}</td>
       <td>—</td>
       <td>${fmtTime(when)}</td>`;
  }

  function updateRowToError(tr, code, when, err){
    tr.innerHTML =
      `<td class="name"><span class="bad">Lookup error</span></td>
       <td class="code">${esc(code)}</td>
       <td>—</td>
       <td>${fmtTime(when)}</td>`;
  }

  function trimHistory(){
    while (historyBody.children.length > HISTORY_MAX) {
      historyBody.lastChild.remove();
    }
  }

  /**************** KEYBOARD-WEDGE LISTENER ****************/
  const SCAN_GAP_MS = 10;   // <=18ms between keys => scanner
  let lastKeyTs = 0;
  let wedgeBuf = "";
  let wedgeResetTimer = null;

  window.addEventListener('keydown', (e)=>{
    if (IS_MODAL_OPEN || isModalVisible()) return;
    keepFocus();

    const now = performance.now();
    const gap = now - (lastKeyTs || now);
    lastKeyTs = now;

    if (e.key === 'Enter'){
      const finished = wedgeBuf;
      wedgeBuf = "";
      if (finished){
        e.preventDefault();
        onScan(finished);
        manualInput.value = '';
      }
      return;
    }

    if (e.key.length === 1){
      const looksLikeScanner = gap <= SCAN_GAP_MS && (wedgeBuf.length > 0 || gap > 0);
      if (looksLikeScanner){
        e.preventDefault();
        wedgeBuf += e.key;
      }
    }

    clearTimeout(wedgeResetTimer);
    wedgeResetTimer = setTimeout(()=> { wedgeBuf = ""; }, 200);
  }, true);

  function beepBad(){
    try{
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type = 'square'; o.frequency.value = 220; // A3
      g.gain.setValueAtTime(0.001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
      o.connect(g).connect(ctx.destination); o.start(); o.stop(ctx.currentTime + 0.26);
    }catch{}
  }

  /**************** MANUAL ENTRY FORM ****************/
  document.getElementById('manualForm').addEventListener('submit', (e)=>{
    e.preventDefault();
    if (IS_MODAL_OPEN || isModalVisible()) return;
    const v = manualInput.value.trim();
    if (v) onScan(v);
    manualInput.value = '';
    keepFocus();
  });

  function keepFocus(){
    if (IS_MODAL_OPEN || isModalVisible()) return;
    if (document.activeElement !== manualInput) manualInput.focus({preventScroll:true});
    manualInput.setSelectionRange(manualInput.value.length, manualInput.value.length);
  }
  keepFocus(); setInterval(keepFocus, 1000);

  /**************** Online/offline indicator + location init ****************/
  function updateOnlinePill(){
    const on = navigator.onLine;
    onlinePill.textContent = on ? 'Online' : 'Offline';
    onlinePill.style.background = on ? '#eaf7ea' : '#fff3e0';
    onlinePill.style.color = on ? '#0a7c2f' : '#8a5a00';
  }
  window.addEventListener('online', updateOnlinePill);
  window.addEventListener('offline', updateOnlinePill);
  updateOnlinePill();

  // Ask for location on load (once)
  promptForLocation(false);

  // Allow changing later
  document.getElementById('locationPill').addEventListener('click', () => {
    promptForLocation(true);
  });

  // Safety net: delegated click handler in case of re-render
  document.body.addEventListener('click', (e)=>{
    const t = e.target;
    if (t && (t.id === 'locationPill' || t.closest?.('#locationPill'))) {
      e.preventDefault();
      promptForLocation(true);
    }
  });
  
  // Kick off the wake lock once on load (will retry on visibility/focus/first input)
  requestWakeLock();

  /**************** KEEP SCREEN AWAKE (Wake Lock) ****************/
  let wakeLock = null;
  
  async function requestWakeLock() {
    if (!('wakeLock' in navigator)) return; // not supported (rare on ChromeOS)
    try {
      // Request or re-request if previously released
      wakeLock = await navigator.wakeLock.request('screen');
      // If the lock gets released (tab lost visibility, etc.), try to reacquire
      wakeLock.addEventListener('release', () => {
        // Attempt to re-acquire when visible again
        if (document.visibilityState === 'visible') {
          requestWakeLock();
        }
      });
    } catch (err) {
      // Usually happens if not in a visible tab or without a user gesture—retry later
      // console.warn('WakeLock error:', err);
    }
  }
  
  // Reacquire on visibility/focus returns (Chromium quirk)
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') requestWakeLock();
  });
  window.addEventListener('focus', requestWakeLock);
  
  // Helpful: first user interaction guarantees a gesture-backed call
  window.addEventListener('keydown', requestWakeLock, { once: true });
  window.addEventListener('pointerdown', requestWakeLock, { once: true });
  </script>
</body>
</html>
