<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/png" sizes="32x32" href="./icons/icon-32.png">
  <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png">
  <link rel="apple-touch-icon" href="./icons/icon-192.png">
  <title>Student Scanner</title>
  
  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest" />
  <meta name="theme-color" content="#0b57d0" />
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(()=>{});
    }
  </script>

  <style>
    :root {
      --fg:#0b1320;
      --muted:#5e6b7a;
    
      /* THEME VARIABLES (default = ‚Äúmorning‚Äù theme) */
      --bg-main:#f6f8fb;
      --card-bg:#ffffff;
      --panel-bg:#fafbff;
      --panel-border:#eef1f7;
      --accent:#0b57d0;
      --pill-bg:#eaf7ea;
      --pill-fg:#0a7c2f;
    }
    
    html,body { height:100%; }
    
    body {
      margin:0;
      font:16px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:var(--fg);
      background:var(--bg-main);
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:100dvh;
    }
    
    /* THEME OVERRIDES */
    body[data-theme="bathroom"] {
      --bg-main:#2b0507;
      --card-bg:#fff5f5;
      --panel-bg:#fff7f7;
      --panel-border:#f3c1c1;
      --accent:#c62828;
      --pill-bg:#fdecea;
      --pill-fg:#b00020;
    }
    
    body[data-theme="lunch"] {
      --bg-main:#16052b;
      --card-bg:#f7f2ff;
      --panel-bg:#f4e9ff;
      --panel-border:#d7c4ff;
      --accent:#7e3ff2;
      --pill-bg:#ede9fe;
      --pill-fg:#4c1d95;
    }

    body[data-theme="class"] {
      /* Class kiosk = calm green theme */
      --bg-main:#041711;
      --card-bg:#f1fbf4;
      --panel-bg:#e7f6ec;
      --panel-border:#b5e1c4;
      --accent:#0a7c2f;
      --pill-bg:#eaf7ea;
      --pill-fg:#0a7c2f;
    }
    
    .card {
      width:min(920px, 96vw);
      background:var(--card-bg);
      border-radius:18px;
      padding:20px 20px 16px;
      box-shadow:0 10px 30px rgba(0,0,0,.06);
    }
    
    .panel {
      background:var(--panel-bg);
      border:1px solid var(--panel-border);
      border-radius:14px;
      padding:14px;
    }
    
    button {
      cursor:pointer;
      border:none;
      border-radius:12px;
      padding:10px 14px;
      font-weight:600;
      background:var(--accent);
      color:#fff;
    }
    
    .pill {
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      background:var(--pill-bg);
      color:var(--pill-fg);
      font-size:12px;
      font-weight:700;
    }
    .scans-pane{ max-height: 360px; overflow-y: auto; border: 1px solid #e5e9f2; border-radius: 8px; background: #fff; }
    .scans-pane thead th{ position: sticky; top: 0; background: #f7f9fc; z-index: 1; box-shadow: 0 1px 0 rgba(0,0,0,0.06); }
    #historyTbl td, #historyTbl th{ padding: 8px 10px; line-height: 1.2; }
    .bad { color:#b00020; font-weight:600; }
    .queued { color:#8a5a00; font-weight:600; }
    .allowed-badge { color:#0a7c2f; font-weight:700; }
    .not-allowed-badge { color:#b00020; font-weight:700; }
    .badge{display:inline-block;padding:2px 10px;border-radius:999px;font-size:12px;font-weight:700}
    .badge--out{background:#eaf7ea;color:#b00020}
    .badge--in{ background:#eaf7ea;color:#0a7c2f}
    .badge--na{ background:#fdecea;color:#b00020}
    .flag{display:inline-flex;align-items:center;gap:6px;font-size:12px;color:#334;user-select:none}
    .flag input{accent-color:#0b57d0}

    /* Bag search highlight */
    .flag-search { background:#fff8db; }
    .flag-search .name::after { content:' ‚Äî SEARCH'; color:#b26b00; font-weight:700; }
    /* Regents Prep badge */
    .badge-purple { background:#f3e8ff; color:#6b21a8; font-weight:700; padding:2px 6px; border-radius:6px; font-size:12px; margin-left:6px; }
    /* Generic Alert badge (blue) */
    .badge-alert {
      background:#e3f2fd;
      color:#0b57d0;
      font-weight:700;
      padding:2px 6px;
      border-radius:6px;
      font-size:12px;
      margin-left:4px;
    }
    /* Modal + UI states */
    #locModal { position:fixed; inset:0; z-index: 2147483000; }
    .card[inert] { pointer-events: none; }
    .pill--bad { background:#fdecea !important; color:#b00020 !important; }
    .pill--warn{ background:#fff3e0 !important; color:#8a5a00 !important; }
    h1 {
      margin:0 0 4px 0;
      font-size:22px;
    }
    
    .muted {
      color:var(--muted);
      font-size:13px;
    }
    
    .row {
      display:flex;
      gap:18px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    
    .col {
      flex:1 1 320px;
    }
    
    /* History / table base styles */
    table {
      width:100%;
      border-collapse:collapse;
      font-size:14px;
    }
    th,td {
      padding:8px 6px;
      border-bottom:1px solid #edf1f6;
      text-align:left;
    }
    th {
      font-weight:600;
      color:#667;
      background:#f8f9fc;
    }
    
    /* Status + text styles */
    .ok { color:#0a7c2f; font-weight:600; }
    .err { color:#b00020; font-weight:600; }
    .name { font-weight:700; }
    .code {
      color:#556;
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    
    /* Manual entry input */
    .input-wrap {
      display:flex;
      gap:8px;
      align-items:center;
    }
    input[type=text] {
      flex:1;
      padding:10px 12px;
      font-size:18px;
      border-radius:12px;
      border:1px solid #cfd7e3;
      outline:none;
    }
    
    /* Locker color swatch */
    .swatch{
      display:inline-block;
      width:10px;
      height:10px;
      border-radius:50%;
      vertical-align:middle;
      margin-right:6px;
      border:1px solid #ccd3de;
    }

    /* Wrong-class popup */
    .popup{
      position:fixed;
      left:50%;
      bottom:20px;
      transform:translate(-50%, 10px);
      background:#b00020;
      color:#fff;
      padding:8px 14px;
      border-radius:999px;
      font-size:14px;
      box-shadow:0 6px 20px rgba(0,0,0,.25);
      opacity:0;
      pointer-events:none;
      z-index:2147483000;
      transition:opacity .2s ease-out, transform .2s ease-out;
    }
    .popup.visible{
      opacity:1;
      transform:translate(-50%, 0);
    }

    /* === Out-of-Class Reason Modal (class kiosks) === */
    .modal-backdrop {
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.65);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:2147483001;
    }
    .modal {
      background:#fff;
      border-radius:16px;
      padding:20px;
      max-width:480px;
      width:90%;
      box-shadow:0 10px 40px rgba(0,0,0,0.3);
      text-align:center;
    }
    .out-modal-student {
      font-size:1.1rem;
      margin-bottom:16px;
    }
    .out-reason-grid {
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:12px;
      margin-bottom:16px;
    }
    .out-reason-btn {
      font-size:1.1rem;
      padding:16px 8px;
      border-radius:12px;
      border:none;
      cursor:pointer;
      touch-action:manipulation;
    }
    .out-reason-cancel {
      font-size:1rem;
      padding:10px 16px;
      border-radius:8px;
      border:none;
      touch-action:manipulation;
    }
  </style>
</head>
<body>
  <!-- ============ LOCATION MODAL ============ -->
  <div id="locModal" style="background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center;">
    <div style="background:#fff; width:min(360px, 92vw); border-radius:14px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.2)">
      <div style="font-weight:700; margin-bottom:8px;">Select your location</div>
      <div class="muted" style="margin-bottom:12px">This will be saved and attached to each scan.</div>
      <select id="locSelect" style="width:100%; padding:10px; border:1px solid #cfd7e3; border-radius:10px; margin-bottom:12px">
        <option value="">Loading‚Ä¶</option>
      </select>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="locCancelBtn" style="background:#e5e9f2; color:#333">Cancel</button>
        <button id="locSaveBtn">Save</button>
      </div>
    </div>
  </div>

  <!-- ============ OUT-OF-CLASS MODAL (CLASS MODE) ============ -->
  <div id="outModal" class="modal-backdrop" style="display:none;">
    <div class="modal">
      <h2 id="outModalTitle">Where is this student going?</h2>
      <p id="outModalStudent" class="out-modal-student"></p>
      <div class="out-reason-grid">
        <button class="out-reason-btn" data-reason="Bathroom">Bathroom</button>
        <button class="out-reason-btn" data-reason="Nurse">Nurse</button>
        <button class="out-reason-btn" data-reason="Main Office">Main Office</button>
        <button class="out-reason-btn" data-reason="Dean">Dean</button>
        <button class="out-reason-btn" data-reason="Social Worker">Social Worker</button>
        <button class="out-reason-btn" data-reason="Other">Other</button>
      </div>
      <button id="outModalCancel" class="out-reason-cancel">Cancel</button>
    </div>
  </div>

  <!-- ============ MAIN CARD ============ -->
  <div class="card">
    <h1>Student Scanner 
      <span class="pill" id="onlinePill">Online</span>
      <span class="pill" id="locationPill" style="margin-left:6px; cursor:pointer;" title="Click to change location">Set location</span>
      <span class="pill" id="batteryPill" style="margin-left:6px">üîã --%</span>
      <span class="pill" id="netPill" style="margin-left:6px">Wi-Fi ‚Ä¶</span>
    </h1>
    <div class="muted">RFID keyboard-wedge or keypad: enter OSIS/RFID + Enter.</div>

    <div class="row" style="margin-top:14px">
      <!-- Left -->
      <div class="col">
        <div class="panel">
          <div id="status">Ready. Scan a card‚Ä¶</div>
          <div id="result"></div>

          <hr style="border:none;border-top:1px solid #edf1f6; margin:12px -14px" />

          <div class="muted" style="margin-bottom:6px">Manual entry:</div>
          <form id="manualForm" class="input-wrap" autocomplete="off">
            <input id="manualInput" type="text" inputmode="none" pattern="[0-9]*" placeholder="Type OSIS or RFID and press Enter" />
            <button type="submit">Enter</button>
          </form>
          <div class="muted" style="margin-top:6px">Tip: field keeps focus‚Äîgreat for external keypads.</div>
        </div>
      </div>

      <!-- Right -->
      <div class="col">
        <!-- History -->
        <div class="panel">
          <div class="muted" style="margin-bottom:8px">Recent scans (local)</div>
          <div id="scansPane" class="scans-pane">
            <table id="historyTbl" aria-label="Scan history">
              <thead>
                <tr>
                  <th style="width:30%">Name</th>
                  <th style="width:20%">Code</th>
                  <th style="width:22%">Locker</th>
                  <th style="width:28%">Time</th>
                </tr>
              </thead>
              <tbody id="historyBody"></tbody>
            </table>
          </div>
        </div>

        <!-- Senior Lunch OUT list -->
        <div class="panel" id="outPanel" style="margin-top:10px; display:none">
          <div class="muted" style="margin-bottom:8px; display:flex; align-items:center; justify-content:space-between;">
            <span>Currently OUT ‚Äî Senior Lunch</span>
            <button id="refreshRosterBtn" style="background:#e7f0fe; color:#0b57d0; padding:6px 10px; border-radius:10px; font-size:12px;">
              Clear list
            </button>
          </div>
          <div id="outPane" class="scans-pane" style="max-height: 240px">
            <table id="outTbl" aria-label="Currently OUT">
              <thead>
                <tr>
                  <th style="width:40%">Name</th>
                  <th style="width:20%">OSIS</th>
                  <th style="width:40%">Since</th>
                </tr>
              </thead>
              <tbody id="outBody"></tbody>
            </table>
          </div>
        </div>

        <!-- Out of Classroom list (class kiosks) -->
        <div class="panel" id="classOutPanel" style="margin-top:10px; display:none">
          <div class="muted" style="margin-bottom:8px;">
            Out of Classroom
          </div>
          <div class="scans-pane" style="max-height:240px">
            <table aria-label="Out of Classroom">
              <thead>
                <tr>
                  <th style="width:40%">Student</th>
                  <th style="width:30%">Reason</th>
                  <th style="width:30%">Time Elapsed</th>
                </tr>
              </thead>
              <tbody id="classOutBody"></tbody>
            </table>
          </div>
        </div>

        <!-- Bathroom IN lists (Male & Female) -->
        <div class="row">
          <div class="col">
            <div class="panel" id="bathPanelM" style="margin-top:10px; display:none">
              <div class="muted" style="margin-bottom:8px; display:flex; align-items:center; justify-content:space-between;">
                <span id="bathPanelTitleM">Currently IN ‚Äî Bathroom (M)</span>
                <button id="bathRefreshBtnM" style="background:#e7f0fe; color:#0b57d0; padding:6px 10px; border-radius:10px; font-size:12px;">Clear Bathroom</button>
              </div>
              <div class="scans-pane" style="max-height: 240px">
                <table aria-label="Currently IN (Bathroom M)">
                  <thead><tr><th style="width:40%">Name</th><th style="width:20%">OSIS</th><th style="width:20%">Since</th><th style="width:20%">Class</th></tr></thead>
                  <tbody id="bathBodyM"></tbody>
                </table>
              </div>
            </div>
          </div>
          <div class="col">
            <div class="panel" id="bathPanelF" style="margin-top:10px; display:none">
              <div class="muted" style="margin-bottom:8px; display:flex; align-items:center; justify-content:space-between;">
                <span id="bathPanelTitleF">Currently IN ‚Äî Bathroom (F)</span>
                <button id="bathRefreshBtnF" style="background:#e7f0fe; color:#0b57d0; padding:6px 10px; border-radius:10px; font-size:12px;">Clear Bathroom</button>
              </div>
              <div class="scans-pane" style="max-height: 240px">
                <table aria-label="Currently IN (Bathroom F)">
                  <thead><tr><th style="width:40%">Name</th><th style="width:20%">OSIS</th><th style="width:20%">Since</th><th style="width:20%">Class</th></tr></thead>
                  <tbody id="bathBodyF"></tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
        
        <!-- RFID Debug panel (only visible in DEBUG locations) -->
        <div class="panel" id="debugPanel" style="margin-top:10px; display:none;">
          <div class="muted" style="margin-bottom:6px;">
            RFID Debug ‚Äî raw keystrokes
          </div>
          <div class="scans-pane" style="max-height: 240px;">
            <pre id="debugLog" style="font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; margin:0; white-space:pre-wrap;"></pre>
          </div>
        </div>

        
      </div>
    </div>

    <div class="muted" style="margin-top:10px">
      Configure <span class="code">API_BASE</span> in the script below.
    </div>
  </div>

  <!-- Small red popup for wrong-class redirects -->
  <div id="classPopup" class="popup" aria-live="polite"></div>

  <script>
  /* ============================================================
   * CONFIG + CONSTANTS
   * ============================================================ */

  // --- Recent scans display limits ---
  const DEFAULT_RECENT_VISIBLE = 6;
  const BATHROOM_RECENT_VISIBLE = 3;
  const isBathroom = (name) => String(name || '').toLowerCase().startsWith('bathroom (');
  const API_BASE = 'https://red-cake-77d5.evazquez-3e0.workers.dev/';

  (async () => { try {
    await fetch(API_BASE, { method: 'POST', body: new URLSearchParams({ action: 'ping' }) });
  } catch (_) {} })();

  const STATIC_LOCATIONS = [
    'Front Desk','Main Entrance','Cafeteria','Gym','Security','Room 302','Senior Lunch (out-in)',
    'Bathroom (First Floor)','Bathroom (Second Floor)','Bathroom (Third Floor)'
  ];

  const HISTORY_VISIBLE_DEFAULT = 10;
  const HISTORY_VISIBLE_SENIOR  = 4;
  const HISTORY_VISIBLE_CLASS = 3;

  const SPECIAL_LOCATION = 'Senior Lunch (out-in)';
  const BATHROOM_PREFIX  = 'Bathroom (';

  const QUEUE_KEY = 'scanQueueV1';
  const LOC_KEY   = 'scannerLocationV1';
  const OUT_KEY   = 'seniorOutV1';
  const BATH_KEY  = 'bathroomInV1';
  const CLASS_PRESENT_KEY = 'classPresentV1';
  const CLASS_OUT_KEY = 'classOutV1';

  const BATHROOM_CAPACITY_DEFAULT = 2;
  let __LOCATIONS_CAPS = null;
  let __LOCATIONS_META = {}; // name -> { type, mode, visible }
  const BATH_CAP_CACHE = Object.create(null);

  // DOM
  const statusEl = document.getElementById('status');
  const resultEl = document.getElementById('result');
  const historyBody = document.getElementById('historyBody');
  const manualInput = document.getElementById('manualInput');
  const onlinePill = document.getElementById('onlinePill');
  const locationPill = document.getElementById('locationPill');
  const cardEl = document.querySelector('.card');

  const classOutPanel = document.getElementById('classOutPanel');
  const classOutBody = document.getElementById('classOutBody');

  const outModal = document.getElementById('outModal');
  const outModalStudent = document.getElementById('outModalStudent');
  const outModalCancel = document.getElementById('outModalCancel');
  const outReasonButtons = Array.from(document.querySelectorAll('.out-reason-btn') || []);

  // Runtime state
  let IS_MODAL_OPEN = false;
  let IS_LOCATION_LOCKED = false;
  let IS_REFRESHING = false;
  let DEBUG_BUFFER = '';
  let DEBUG_LAST_TS = 0;
  let DEBUG_EVENTS = [];

  function clearManualInput() {
    if (!manualInput) return;
    manualInput.value = '';
  }
    
  function debugLogLine(text) {
    const logEl = document.getElementById('debugLog');
    if (!logEl) return;
    const now = new Date();
    const ts = fmtTime(now);
    logEl.textContent += `[${ts}] ${text}\n`;
    // keep log from growing forever
    const maxLen = 8000;
    if (logEl.textContent.length > maxLen) {
      logEl.textContent = logEl.textContent.slice(-maxLen);
    }
    const pane = logEl.parentElement;
    if (pane && pane.scrollTop != null) {
      pane.scrollTop = pane.scrollHeight;
    }
  }
  
  function handleDebugKey(e) {
    const now = performance.now();
    const gap = DEBUG_LAST_TS ? (now - DEBUG_LAST_TS) : 0;
    DEBUG_LAST_TS = now;
  
    // 1) Keep on-screen debug log
    debugLogLine(
      `key=${JSON.stringify(e.key)} code=${e.code} keyCode=${e.keyCode} gapMs=${gap.toFixed(1)}`
    );
  
    // 2) Track per-scan event list
    DEBUG_EVENTS.push({
      key: e.key,
      code: e.code,
      keyCode: e.keyCode,
      gapMs: Number(gap.toFixed(1)),
      tsPerf: now
    });
  
    if (e.key === 'Enter') {
      // End of one RFID "scan" according to wedge
      const sample = {
        ts: Date.now(),
        buffer: DEBUG_BUFFER,
        events: DEBUG_EVENTS.slice()
      };
  
      debugLogLine(`SCAN COMPLETE buffer=${JSON.stringify(DEBUG_BUFFER)}`);
  
      // Fire-and-forget send to backend
      apiDebugLog(sample);
  
      // Reset for next scan
      DEBUG_BUFFER = '';
      DEBUG_EVENTS = [];
      if (manualInput) manualInput.value = '';
    } else if (e.key.length === 1) {
      DEBUG_BUFFER += e.key;
    }
  }

  // Class-mode state
  const CLASS_PRESENT = Object.create(null); // osis -> { firstIn, lastIn }
  const OUT_OF_CLASS = Object.create(null);  // osis -> { name, reason, startedAt, rowEl, timeEl, timerId }
  let CURRENT_CLASS_PENDING = null;
  let CURRENT_CLASS_PERIOD_KEY = null; // tracks which period this kiosk session is for

  // Device fingerprint
  const DEVICE_ID = (localStorage.getItem('scannerDeviceId') ||
    (localStorage.setItem('scannerDeviceId', crypto.randomUUID()), localStorage.getItem('scannerDeviceId')));

  function getLocationMeta(loc) {
    const name = String(loc || getLocation() || '').trim();
    return __LOCATIONS_META[name] || {};
  }

  /* ============================================================
   * SMALL HELPERS
   * ============================================================ */
  function classBucketKeyFor(periodKey) {
    const loc = getLocation() || '';
    const p   = periodKey || 'unknown';
    return `${todayKey()}|${loc.toLowerCase()}|${p}|${DEVICE_ID}`;
  }
  
  function loadClassPresentMap() {
    try {
      return JSON.parse(localStorage.getItem(CLASS_PRESENT_KEY) || '{}');
    } catch {
      return {};
    }
  }
  
  function saveClassPresentMap(map) {
    localStorage.setItem(CLASS_PRESENT_KEY, JSON.stringify(map));
  }
  
  function getClassPresentList(bucketKey) {
    const map = loadClassPresentMap();
    return map[bucketKey] || [];
  }
  
  function setClassPresentList(bucketKey, list) {
    const map = loadClassPresentMap();
    map[bucketKey] = list;
    saveClassPresentMap(map);
  }
  
  // Rebuild CLASS_PRESENT in memory from localStorage for current period
  function hydrateClassPresentFromStorage(periodKey) {
    Object.keys(CLASS_PRESENT).forEach(k => delete CLASS_PRESENT[k]);
    if (!periodKey) return;
  
    const bucket = classBucketKeyFor(periodKey);
    const list   = getClassPresentList(bucket);
  
    const now = Date.now();
    for (const osis of list) {
      CLASS_PRESENT[osis] = { firstIn: now, lastIn: now };
    }
  }
  function nameHtmlWithBadge(name){
    const loc = getLocation();
  
    const inMorningContext =
      !isSeniorOutIn() &&
      !isBathroomLocation(loc) &&
      !isLunchLocation(loc);
  
    const badges = [];
  
    if (inMorningContext && window.__lastRegentsPrep) {
      badges.push('<span class="badge-purple">REGENTS PREP</span>');
    }
  
    if (inMorningContext && window.__lastAlertFlag) {
      badges.push('<span class="badge-alert">ALERT</span>');
    }
  
    const maxBadges = 2;
    const rendered = badges.slice(0, maxBadges).join('');
  
    return `${esc(name || 'Unknown')}${rendered ? ' ' + rendered : ''}`;
  }
  // ---- Out-of-Class (class kiosks) persistence ----
  function loadClassOutMap() {
    try {
      return JSON.parse(localStorage.getItem(CLASS_OUT_KEY) || '{}');
    } catch {
      return {};
    }
  }
  
  function saveClassOutMap(map) {
    localStorage.setItem(CLASS_OUT_KEY, JSON.stringify(map));
  }
  
  function getClassOutList(bucketKey) {
    const map = loadClassOutMap();
    return map[bucketKey] || [];
  }
  
  function setClassOutList(bucketKey, list) {
    const map = loadClassOutMap();
    map[bucketKey] = list;
    saveClassOutMap(map);
  }
  
  // Rebuild OUT_OF_CLASS + table from localStorage for current period
  let __HYDRATING_OUT = false;
  
  function hydrateOutOfClassFromStorage(periodKey) {
    // Clear any old timers + rows
    Object.keys(OUT_OF_CLASS).forEach(osis => {
      const entry = OUT_OF_CLASS[osis];
      if (entry && entry.timerId) clearInterval(entry.timerId);
      delete OUT_OF_CLASS[osis];
    });
    if (classOutBody) classOutBody.innerHTML = '';
  
    if (!periodKey) {
      ensureClassOutVisibility();
      return;
    }
  
    const bucket = classBucketKeyFor(periodKey);
    const list   = getClassOutList(bucket);
  
    __HYDRATING_OUT = true;
    try {
      for (const rec of list) {
        const osis   = String(rec.osis || '').trim();
        if (!osis) continue;
        const name   = rec.name   || '';
        const reason = rec.reason || 'OUT';
  
        let startMs;
        if (rec.startedAtMs) {
          startMs = rec.startedAtMs;
        } else if (rec.startedAtISO) {
          const t = Date.parse(rec.startedAtISO);
          startMs = Number.isFinite(t) ? t : Date.now();
        } else {
          startMs = Date.now();
        }
  
        // Rebuild entry & row; addClassOutEntry will skip re-saving while hydrating
        addClassOutEntry(osis, name, reason, startMs);
      }
    } finally {
      __HYDRATING_OUT = false;
    }
  
    ensureClassOutVisibility();
  }
  function esc(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function setStatus(t){ statusEl.textContent = t; }
  function getLocation(){ return localStorage.getItem(LOC_KEY) || ''; }
  function setLocation(v){ localStorage.setItem(LOC_KEY, v || ''); updateLocationPill(); }
  function todayKey() {
    const d = new Date();
    const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), day = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${day}`;
  }
  function fmtTime(d){ try { return new Intl.DateTimeFormat(undefined,{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false}).format(d); } catch { return d.toLocaleString(); } }

  function formatElapsed(ms){
    const totalSec = Math.floor(ms/1000);
    const m = Math.floor(totalSec/60);
    const s = totalSec % 60;
    return `${m}:${s.toString().padStart(2,'0')}`;
  }

  function isDebugLocation(loc) {
    const current = (loc || getLocation() || '').toLowerCase().trim();
    return current.startsWith('debug'); // e.g. "DEBUG: RFID raw"
  }
  function updateDebugPanelForLocation() {
    const panel = document.getElementById('debugPanel');
    if (!panel) return;
    panel.style.display = isDebugLocation() ? '' : 'none';
  }

  function isSeniorOutIn() {
    const loc = getLocation();
    const meta = getLocationMeta(loc);
    if (meta && meta.mode) {
      return String(meta.mode).toLowerCase() === 'senior_outin';
    }
    return String(loc || '').toLowerCase() === SPECIAL_LOCATION.toLowerCase();
  }
  function isBathroomLocation(loc) {
    const current = loc || getLocation();
    const meta = getLocationMeta(current);
    if (meta && meta.mode) {
      if (String(meta.mode).toLowerCase() === 'bathroom') return true;
    }
    return String(current || '').toLowerCase().startsWith(BATHROOM_PREFIX.toLowerCase());
  }
  function isClassKiosk(loc) {
    const meta = getLocationMeta(loc);
    return meta && String(meta.mode || '').toLowerCase() === 'class';
  }
  function isLunchLocation(loc) {
    const current = loc || getLocation();
    const meta = getLocationMeta(current);
    if (meta && meta.mode) {
      if (String(meta.mode).toLowerCase() === 'lunch') return true;
    }
    const v = String(current || '').toLowerCase().trim();
    return v === 'lunch' || v === 'lunch 1' || v === 'lunch 2';
  }
  function lunchSlotFromLocation(loc){ return String(loc||'').toLowerCase().includes('2') ? 2 : 1; }
  function normalizeLunchValue(s){
    const v = String(s||'').toLowerCase().replace(/\s+/g,'').replace('lunch','').replace('group','').replace('l','');
    const m = v.match(/([12])/); return m ? Number(m[1]) : null;
  }
  function isAllowedForLunch(location, lunchValue){
    const need = lunchSlotFromLocation(location);
    const have = normalizeLunchValue(lunchValue);
    return have === need;
  }
  function normalizeRoomLabelClient(room) {
    if (!room) return null;
    return String(room)
      .replace(/^RM\s*/i, '')
      .trim();
  }

  // === Class-kiosk helpers (uses Worker schedule fields) ===
  function deriveStudentRoomFromResponse(res) {
    if (!res) return null;
    if (res.current_room) {
      return normalizeRoomLabelClient(res.current_room);
    }
    const cn = String(res.class_now || '').trim();
    if (!cn) return null;
    const parts = cn.split('\u2192').map(p => p.trim()).filter(Boolean);
    if (parts.length) {
      const last = parts[parts.length - 1];
      return normalizeRoomLabelClient(last);
    }
    return normalizeRoomLabelClient(cn);
  }

  function deriveClassDisplayLabel(res, studentRoom) {
    if (res && res.class_now) return res.class_now;
    if (studentRoom) return studentRoom;
    if (res && res.current_period) return `Period ${res.current_period}`;
    return 'your scheduled class';
  }

  let __classPopupTimer = null;
  function showClassPopup(msg){
    const el = document.getElementById('classPopup');
    if (!el) return;
    el.textContent = msg;
    el.classList.add('visible');
    if (__classPopupTimer) clearTimeout(__classPopupTimer);
    __classPopupTimer = setTimeout(()=>{ el.classList.remove('visible'); }, 2500);
  }

  window.showClassPopup = showClassPopup;
  
  function showWrongClass(name, code, label, when){
    const nameHtml = nameHtmlWithBadge(name);
    resultEl.innerHTML =
      `<div class="err">Wrong class</div>
       <div class="name">${nameHtml}</div>
       <div class="code">${esc(code)} ‚Äî You should be in ${esc(label || 'your scheduled class')} right now.</div>
       <div class="muted">${fmtTime(when)}</div>`;
  }

  function showClassRedirect(code, shouldRoom, when){
    beepBad();
    const msg = shouldRoom
      ? `You should be in ${esc(shouldRoom)}.`
      : 'You should be in a different class right now.';
  
    resultEl.innerHTML =
      `<div class="err">Wrong class</div>
       <div class="code">${esc(code)}</div>
       <div class="muted">${fmtTime(when)} ‚Äî ${esc(msg)}</div>`;
  
    setStatus('Wrong class.');
  }

  function updateRowToWrongClass(tr, {name, code, when, label}){
    const nameHtml = nameHtmlWithBadge(name);
    tr.className = '';
    tr.innerHTML =
      `<td class="name">${nameHtml}</td>
       <td class="code">${esc(code)}</td>
       <td><span class="badge badge--na">Wrong class</span></td>
       <td>${fmtTime(when)}</td>`;
  }

  function checkClassKioskEligibility(kioskRoom, res) {
    if (!kioskRoom) {
      return { ok:true, studentRoom:null, displayLabel:null };
    }
    const studentRoom = deriveStudentRoomFromResponse(res);
    if (!studentRoom) {
      return { ok:true, studentRoom:null, displayLabel:null };
    }
    const same = studentRoom.toLowerCase() === kioskRoom.toLowerCase();
    return {
      ok: same,
      studentRoom,
      displayLabel: deriveClassDisplayLabel(res, studentRoom)
    };
  }

  function deriveKioskPeriodKeyFromResponse(res) {
    // Prefer the ‚Äúcurrent‚Äù period if we have it
    if (res && res.current_period != null) {
      return String(res.current_period);
    }
    // During transition / early window, we can anchor on the *next* period
    if (res && res.next_period != null) {
      return String(res.next_period);
    }
    return null;
  }
  
  function maybeResetClassStateForPeriod(res) {
    const loc = getLocation();
    if (!isClassKiosk(loc)) return;
  
    const key = deriveKioskPeriodKeyFromResponse(res);
    if (!key) return;
  
    // If we already have a period and it changes ‚Üí new class, reset state
    if (CURRENT_CLASS_PERIOD_KEY && CURRENT_CLASS_PERIOD_KEY !== key) {
      logClassTimeoutsForCurrentPeriod();
      resetClassSessionState();
    }
  
    CURRENT_CLASS_PERIOD_KEY = key;
  
    // Rebuild "present" + "OUT" from localStorage for this bucket
    hydrateClassPresentFromStorage(key);
    hydrateOutOfClassFromStorage(key);
  }
    
  function classifyLocationType(locationName){
    const name = String(locationName || '').trim();
    if (!name) return 'default';
  
    const meta = __LOCATIONS_META[name];
    if (meta && meta.type) return meta.type;
  
    const s = name.toLowerCase();
    if (s.startsWith('bathroom')) return 'bathroom';
    if (s.includes('lunch') || s.includes('caf')) return 'lunch';
  
    return 'morning';
  }
  
  function applyThemeForLocation(locationName){
    const theme = classifyLocationType(locationName);
    if (!theme || theme === 'default' || theme === 'morning') {
      document.body.removeAttribute('data-theme');
    } else {
      document.body.setAttribute('data-theme', theme);
    }
  }

  /* ============================================================
   * AUDIO (bad beep)
   * ============================================================ */
  let AUDIO_CTX;
  function getAudioCtx(){
    if (!AUDIO_CTX) AUDIO_CTX = new (window.AudioContext || window.webkitAudioContext)();
    if (AUDIO_CTX.state === 'suspended') AUDIO_CTX.resume().catch(()=>{});
    return AUDIO_CTX;
  }
  ['pointerdown','keydown'].forEach(evt =>
    window.addEventListener(evt, ()=>getAudioCtx(), { once:true })
  );
  function beepOnce({freq=440, dur=0.2, when=0}){
    const ctx = getAudioCtx(); const t = ctx.currentTime + when;
    const osc = ctx.createOscillator(); const g = ctx.createGain();
    osc.type = 'square'; osc.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.2, t+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    osc.connect(g).connect(ctx.destination);
    osc.start(t); osc.stop(t+dur+0.05);
  }
  function beepBad(){
    [
      { freq: 260, dur: 0.51, when: 0.00 },
      { freq: 220, dur: 0.51, when: 0.10 },
      { freq: 260, dur: 0.51, when: 0.20 },
      { freq: 220, dur: 0.51, when: 0.30 }
    ].forEach(p => beepOnce(p));
  }

  /* ============================================================
   * PANES: Senior Lunch OUT; Bathroom IN lists (LOCAL storage)
   * ============================================================ */
  function outBucketKey(){ return `${todayKey()}|${(getLocation()||'').toLowerCase()}`; }
  function loadOutMap(){ try { return JSON.parse(localStorage.getItem(OUT_KEY) || '{}'); } catch { return {}; } }
  function saveOutMap(map){ localStorage.setItem(OUT_KEY, JSON.stringify(map)); }
  function getOutSet(){ const map = loadOutMap(); return map[outBucketKey()] || []; }
  function setOutSet(list){ const map = loadOutMap(); map[outBucketKey()] = list; saveOutMap(map); }
  function isOutNow(osis){ return getOutSet().some(x => x.osis === String(osis||'').trim()); }
  function addOut(osis, name, when=new Date()){
    osis = String(osis||'').trim(); if (!osis) return;
    const list = getOutSet();
    if (!list.some(x => x.osis === osis)) { list.unshift({ osis, name:String(name||'').trim(), sinceISO: when.toISOString() }); setOutSet(list); }
  }
  function removeOut(osis){ setOutSet(getOutSet().filter(x => x.osis !== String(osis||'').trim())); }
  function renderOutList(){
    const outPanel = document.getElementById('outPanel');
    const outBody  = document.getElementById('outBody');
    const show = isSeniorOutIn();
    outPanel.style.display = show ? '' : 'none';
    if (!show) return;
    const rows = getOutSet();
    outBody.innerHTML = rows.map(r => {
      const when = new Date(r.sinceISO);
      return `<tr>
        <td class="name">${esc(r.name || '‚Äî')}</td>
        <td class="code">${esc(r.osis || '')}</td>
        <td>${fmtTime(when)}</td>
      </tr>`;
    }).join('');
  }

  // Bathroom (IN lists) ‚Äî gendered
  function bathBucketKeyG(g){ return `${todayKey()}|${(getLocation()||'').toLowerCase()}|${(g||'').toUpperCase()}`; }
  function loadBathMap(){ try { return JSON.parse(localStorage.getItem(BATH_KEY) || '{}'); } catch { return {}; } }
  function saveBathMap(map){ localStorage.setItem(BATH_KEY, JSON.stringify(map)); }
  function getBathSet(g){ const map = loadBathMap(); return map[bathBucketKeyG(g)] || []; }
  function setBathSet(g, list){ const map = loadBathMap(); map[bathBucketKeyG(g)] = list; saveBathMap(map); }
  function isInBathroomG(g, osis){ return getBathSet(g).some(x => x.osis === String(osis||'').trim()); }
  function addInBathroomG(g, osis, name, when=new Date(), cls=''){
    osis = String(osis||'').trim();
    if (!osis) return;
  
    const list = getBathSet(g);
    const rec = {
      osis,
      name: String(name || '').trim(),
      sinceISO: when.toISOString()
    };
    if (cls) rec.cls = String(cls);
  
    const idx = list.findIndex(x => x.osis === osis);
    if (idx >= 0) list.splice(idx, 1, rec);
    else list.unshift(rec);
  
    setBathSet(g, list);
  }
  function removeFromBathroomG(g, osis){ setBathSet(g, getBathSet(g).filter(x => x.osis !== String(osis||'').trim())); }

  async function getBathroomCapacityRemote(loc, gender) {
    if (__LOCATIONS_CAPS && __LOCATIONS_CAPS[loc] && typeof __LOCATIONS_CAPS[loc] === 'object') {
      // placeholder for per-gender preload
    }
    try {
      const body = new URLSearchParams({ action: 'bath_cap', location: loc });
      if (gender) body.set('gender', gender);
      const r = await fetch(API_BASE, { method: 'POST', body });
      const ct = r.headers.get('content-type')||''; if (!r.ok || !ct.includes('application/json')) throw 0;
      const data = await r.json();
      const cap = Number(data?.cap);
      return Number.isFinite(cap) && cap > 0 ? cap : BATHROOM_CAPACITY_DEFAULT;
    } catch { return BATHROOM_CAPACITY_DEFAULT; }
  }
  async function getBathroomCapacity(loc, gender){
    const key = String(loc||'').toLowerCase();
    if (BATH_CAP_CACHE[key]) return BATH_CAP_CACHE[key];
    const cap = await getBathroomCapacityRemote(loc, gender);
    BATH_CAP_CACHE[key] = cap;
    return cap;
  }

  async function renderBathList(){
    const loc = getLocation();
    const show = isBathroomLocation(loc);
    const panelM = document.getElementById('bathPanelM');
    const panelF = document.getElementById('bathPanelF');
    panelM.style.display = show ? '' : 'none';
    panelF.style.display = show ? '' : 'none';
    if (!show) return;

    const [capM, capF] = await Promise.all([ getBathroomCapacity(loc, 'M'), getBathroomCapacity(loc, 'F') ]);
    const bodyM = document.getElementById('bathBodyM');
    const bodyF = document.getElementById('bathBodyF');
    const titleM = document.getElementById('bathPanelTitleM');
    const titleF = document.getElementById('bathPanelTitleF');

    const rowsM = getBathSet('M');
    const rowsF = getBathSet('F');

    if (titleM) titleM.textContent = `Currently IN ‚Äî ${loc} (M cap ${capM})`;
    if (titleF) titleF.textContent = `Currently IN ‚Äî ${loc} (F cap ${capF})`;

    function rowHtml(r){
      const when = new Date(r.sinceISO);
      const cls = r.cls || '';
      return `<tr>
        <td class="name">${esc(r.name || '‚Äî')}</td>
        <td class="code">${esc(r.osis || '')}</td>
        <td>${fmtTime(when)}</td>
        <td>${esc(cls || '‚Äî')}</td>
      </tr>`;
    }
    
    bodyM.innerHTML = rowsM.map(rowHtml).join('');
    bodyF.innerHTML = rowsF.map(rowHtml).join('');
  }

  /* ---------- MINIMAL ADD: manual clear helpers ---------- */
  async function manualClearOutList(){
    const loc = getLocation() || SPECIAL_LOCATION;
    const items = getOutSet();
    if (!items.length){ setStatus('Nothing to clear.'); return; }

    setStatus('Clearing list‚Ä¶');
    const nowISO = new Date().toISOString();
    await Promise.allSettled(items.map(r =>
      apiLog({
        whenISO: nowISO,
        code: r.osis,
        source: 'pwa',
        resolved: { name: r.name || '', osis: r.osis || '' },
        allowed: 'manually_cleared'
      })
    ));
    setOutSet([]);
    renderOutList();
    setStatus('List cleared.');
    setTimeout(()=> setStatus('Ready. Scan a card‚Ä¶'), 1200);
  }

  async function manualClearBathroom(g){
    const loc = getLocation() || '';
    if (!isBathroomLocation(loc)){ setStatus('Not a bathroom location.'); return; }
    const items = getBathSet(g);
    if (!items.length){ setStatus(`Nothing to clear for ${g}.`); return; }

    setStatus(`Clearing Bathroom (${g})‚Ä¶`);
    const nowISO = new Date().toISOString();
    await Promise.allSettled(items.map(r =>
      apiLog({
        whenISO: nowISO,
        code: r.osis,
        source: 'pwa',
        resolved: { name: r.name || '', osis: r.osis || '' },
        allowed: 'manually_cleared'
      })
    ));
    setBathSet(g, []);
    await renderBathList();
    setStatus(`Bathroom (${g}) cleared.`);
    setTimeout(()=> setStatus('Ready. Scan a card‚Ä¶'), 1200);
  }
  /* ---------- END minimal add ---------- */

  /* ============================================================
   * CLASS MODE: OUT-OF-CLASS BUCKET + MODAL
   * ============================================================ */
  function ensureClassOutVisibility(){
    if (!classOutPanel) return;
    const loc = getLocation();
    const onClass = isClassKiosk(loc);
    const any = Object.keys(OUT_OF_CLASS).length > 0;
    classOutPanel.style.display = (onClass && any) ? '' : 'none';
  }

  function clearClassOutEntry(osis){
    const entry = OUT_OF_CLASS[osis];
    if (!entry) return 0;
  
    clearInterval(entry.timerId);
    if (entry.rowEl && entry.rowEl.parentNode) {
      entry.rowEl.parentNode.removeChild(entry.rowEl);
    }
    const elapsed = Date.now() - entry.startedAt;
    delete OUT_OF_CLASS[osis];
  
    // Also remove from localStorage for this period
    if (CURRENT_CLASS_PERIOD_KEY) {
      const bucket = classBucketKeyFor(CURRENT_CLASS_PERIOD_KEY);
      const list   = getClassOutList(bucket).filter(r => r.osis !== osis);
      setClassOutList(bucket, list);
    }
  
    ensureClassOutVisibility();
    return elapsed;
  }

  function addClassOutEntry(osis, name, reason, startedAt){
    if (!classOutPanel || !classOutBody) return;
  
    const existing = OUT_OF_CLASS[osis];
    if (existing) {
      clearInterval(existing.timerId);
      if (existing.rowEl && existing.rowEl.parentNode) {
        existing.rowEl.parentNode.removeChild(existing.rowEl);
      }
    }
  
    const row = document.createElement('tr');
    const nameCell = document.createElement('td');
    const reasonCell = document.createElement('td');
    const timeCell = document.createElement('td');
  
    nameCell.textContent = `${name} (${osis})`;
    reasonCell.textContent = reason;
    timeCell.textContent = '0:00';
  
    row.appendChild(nameCell);
    row.appendChild(reasonCell);
    row.appendChild(timeCell);
    classOutBody.appendChild(row);
  
    const startMs = startedAt instanceof Date
      ? startedAt.getTime()
      : (typeof startedAt === 'number' ? startedAt : Date.now());
  
    const entry = {
      osis,
      name,
      reason,
      startedAt: startMs,
      rowEl: row,
      timeEl: timeCell,
      timerId: null
    };
  
    entry.timerId = setInterval(() => {
      const elapsed = Date.now() - entry.startedAt;
      entry.timeEl.textContent = formatElapsed(elapsed);
    }, 1000);
  
    OUT_OF_CLASS[osis] = entry;
  
    // Persist this OUT entry (but skip when we are hydrating from storage)
    if (!__HYDRATING_OUT && CURRENT_CLASS_PERIOD_KEY) {
      const bucket = classBucketKeyFor(CURRENT_CLASS_PERIOD_KEY);
      const list   = getClassOutList(bucket);
      const rec    = {
        osis,
        name,
        reason,
        startedAtISO: new Date(startMs).toISOString()
      };
      const idx = list.findIndex(r => r.osis === osis);
      if (idx >= 0) list[idx] = rec;
      else list.push(rec);
      setClassOutList(bucket, list);
    }
  
    ensureClassOutVisibility();
  }

  function logClassTimeoutsForCurrentPeriod() {
    // If there‚Äôs no active period yet, nothing to do
    if (!CURRENT_CLASS_PERIOD_KEY) return;
  
    const now = new Date();
    const whenISO = now.toISOString();
  
    Object.keys(OUT_OF_CLASS).forEach(osis => {
      const entry = OUT_OF_CLASS[osis];
      if (!entry) return;
  
      // entry has: { osis, name, reason, startedAt, ... }
      apiLog({
        whenISO,
        code: osis, // log OSIS as the code
        source: 'pwa',
        resolved: {
          name: entry.name || '',
          osis: osis
        },
        // You‚Äôll see this in the log as a ‚Äúclass back in due to timeout‚Äù
        allowed: `class_timeout${entry.reason ? ':' + entry.reason : ''}`
      });
    });
  }

  function resetClassSessionState(){
    Object.keys(OUT_OF_CLASS).forEach(osis => {
      clearClassOutEntry(osis);
    });
    Object.keys(CLASS_PRESENT).forEach(osis => {
      delete CLASS_PRESENT[osis];
    });
    if (classOutBody) classOutBody.innerHTML = '';
    CURRENT_CLASS_PERIOD_KEY = null;
    ensureClassOutVisibility();
  }

  function openOutModalForClass(ctx){
    CURRENT_CLASS_PENDING = ctx;
    if (!outModal || !outModalStudent) return;
    outModalStudent.textContent = `${ctx.res.name} (${ctx.osis})`;
    outModal.style.display = 'flex';
    setModalOpen(true);
  }

  function closeOutModalForClass(){
    if (!outModal) return;
    outModal.style.display = 'none';
    setModalOpen(false);
  }

  async function handleClassOut(reason){
    const ctx = CURRENT_CLASS_PENDING;
    if (!ctx) return;
    CURRENT_CLASS_PENDING = null;

    const { row, code, when, res, osis, shouldRoom } = ctx;
    const whenISO = when.toISOString();
    const loc = getLocation() || '';

    addClassOutEntry(osis, res.name || '', reason, when);

    updateRowToSuccess(row, {
      name: res.name,
      code,
      lockerNum: `OUT: ${reason}`,
      lockerColor: shouldRoom || '',
      when
    });

    showSuccess(res.name, code, `OUT: ${reason}`, shouldRoom || '', when);

    await apiLog({
      whenISO,
      code,
      source:'pwa',
      resolved:res,
      allowed:`class_out:${reason}`
    });

    setStatus('Student marked out of classroom.');
  }

  async function handleClassBackIn(ctx){
    const { row, code, when, res, osis, shouldRoom } = ctx;
    const whenISO = when.toISOString();
    const elapsedMs = clearClassOutEntry(osis);
    const elapsedStr = elapsedMs > 0 ? formatElapsed(elapsedMs) : '0:00';

    if (CLASS_PRESENT[osis]) {
      CLASS_PRESENT[osis].lastIn = Date.now();
    }

    updateRowToSuccess(row, {
      name: res.name,
      code,
      lockerNum: `BACK (${elapsedStr})`,
      lockerColor: shouldRoom || '',
      when
    });

    showSuccess(res.name, code, `BACK (${elapsedStr})`, shouldRoom || '', when);

    await apiLog({
      whenISO,
      code,
      source:'pwa',
      resolved:res,
      allowed:`class_back:${elapsedStr}`
    });

    setStatus('Student back in classroom.');
  }

  if (outModalCancel) {
    outModalCancel.addEventListener('click', () => {
      CURRENT_CLASS_PENDING = null;
      closeOutModalForClass();
    });
  }
  if (outModal) {
    outModal.addEventListener('click', (ev) => {
      if (ev.target === outModal) {
        CURRENT_CLASS_PENDING = null;
        closeOutModalForClass();
      }
    });
  }
  outReasonButtons.forEach(btn => {
    btn.addEventListener('click', async () => {
      const reason = btn.dataset.reason || 'Other';
      closeOutModalForClass();
      handleClassOut(reason);
    });
  });

  /* Attach clear buttons to existing endpoints */
  document.getElementById('bathRefreshBtnM')?.addEventListener('click', async (e)=>{
    const btn = e.currentTarget; btn.disabled = true; const orig = btn.textContent;
    btn.textContent = 'Clearing‚Ä¶'; setStatus('Clearing bathroom (M)‚Ä¶');
    try {
      const loc = getLocation();
      const list = getBathSet('M');
      if (!isBathroomLocation(loc)) { throw new Error('Not a bathroom location.'); }
      if (!list.length) { setStatus('Nothing to clear.'); return; }
  
      const items = list.map(r => ({ osis: r.osis, name: r.name, sex: 'M' }));
      const res = await apiManualClear(loc, items);
      setBathSet('M', []);
      await renderBathList();
      setStatus(`Cleared ${res?.cleared ?? 0} student(s) from (M).`);
    } catch (err) {
      setStatus(`Clear failed ‚Äî ${err.message || err}`);
    } finally {
      btn.textContent = orig; btn.disabled = false;
      setTimeout(()=> setStatus('Ready. Scan a card‚Ä¶'), 1200);
    }
  });
  
  document.getElementById('bathRefreshBtnF')?.addEventListener('click', async (e)=>{
    const btn = e.currentTarget; btn.disabled = true; const orig = btn.textContent;
    btn.textContent = 'Clearing‚Ä¶'; setStatus('Clearing bathroom (F)‚Ä¶');
    try {
      const loc = getLocation();
      const list = getBathSet('F');
      if (!isBathroomLocation(loc)) { throw new Error('Not a bathroom location.'); }
      if (!list.length) { setStatus('Nothing to clear.'); return; }
  
      const items = list.map(r => ({ osis: r.osis, name: r.name, sex: 'F' }));
      const res = await apiManualClear(loc, items);
      setBathSet('F', []);
      await renderBathList();
      setStatus(`Cleared ${res?.cleared ?? 0} student(s) from (F).`);
    } catch (err) {
      setStatus(`Clear failed ‚Äî ${err.message || err}`);
    } finally {
      btn.textContent = orig; btn.disabled = false;
      setTimeout(()=> setStatus('Ready. Scan a card‚Ä¶'), 1200);
    }
  });

  // Console helpers
  window.getBathroomCap = async function(location) {
    location = location || getLocation();
    const r = await fetch(API_BASE, { method: 'POST', body: new URLSearchParams({ action: 'bath_cap', location }) });
    const data = await r.json().catch(()=> ({}));
    console.log('Bathroom cap:', data);
    return data;
  };
  window.setBathroomCap = async function(newCap, location, adminToken) {
    location = location || getLocation();
    if (!location) throw new Error('No location selected.');
    if (!adminToken) adminToken = prompt('Admin token? (x-admin-token)') || '';
    const body = new URLSearchParams({ location, cap: String(newCap) });
    const r = await fetch(new URL('/admin/bath_cap', API_BASE), {
      method: 'POST',
      headers: { 'x-admin-token': adminToken },
      body
    });
    if (!r.ok) { const t = await r.text(); throw new Error(`Failed (${r.status}) ${t.slice(0,120)}`); }
    const data = await r.json();
    if (!__LOCATIONS_CAPS) __LOCATIONS_CAPS = {};
    __LOCATIONS_CAPS[location] = Number(data.cap);
    BATH_CAP_CACHE[String(location).toLowerCase()] = Number(data.cap);
    await renderBathList();
    console.log(`Set cap for "${location}" ‚Üí`, data.cap);
    return data;
  };

  /* ============================================================
   * HEADER / PANES RESPONSIVENESS
   * ============================================================ */
  const historyHeaderCells = document.querySelectorAll('#historyTbl thead th');
  function updateHistoryPaneForLocation(){
    const pane = document.getElementById('scansPane');
    if (!pane) return;
    const loc = getLocation();
  
    if (isSeniorOutIn()) {
      pane.style.maxHeight = '140px';
    } else if (isBathroomLocation(loc)) {
      pane.style.maxHeight = '120px';
    } else if (isClassKiosk(loc)) {
      // Super small for class mode so OUT list stays visible
      pane.style.maxHeight = '90px';
    } else {
      pane.style.maxHeight = '360px';
    }
  }
  function updateHeaderForLocation(){
    const loc = getLocation();
    const col = historyHeaderCells[2];
    if (!col) return;

    if (isSeniorOutIn() || isBathroomLocation(loc)) col.textContent = 'In/Out';
    else if (isLunchLocation(loc)) col.textContent = 'Allowed?';
    else if (isClassKiosk(loc)) col.textContent = 'Attendance';
    else col.textContent = 'Locker';

    if (!isClassKiosk(loc)) {
      resetClassSessionState();
    } else {
      ensureClassOutVisibility();
    }

    renderOutList();
    renderBathList();
    updateHistoryPaneForLocation();
    updateDebugPanelForLocation();
    trimHistory();
  }

  /* ============================================================
   * API CALLS (Worker)
   * ============================================================ */
  async function apiLookup(code){
    const loc = getLocation();
    const body = new URLSearchParams({ action:'lookup', code });

    if (isClassKiosk(loc)) {
      const kioskRoom = normalizeRoomLabelClient(loc);
      if (kioskRoom) {
        body.set('kiosk_room', kioskRoom);
      }
    }
    const wakeTimer = setTimeout(() => setStatus('Waking server‚Ä¶'), 800);
    const controller = new AbortController();
    const abortTimer = setTimeout(() => controller.abort(), 8000);
    try {
      const r = await fetch(API_BASE, { method:'POST', body, signal: controller.signal });
      const ct = r.headers.get('content-type') || '';
      const text = await r.text();
      if (!r.ok) throw new Error(`HTTP ${r.status} ${text.slice(0,120)}`);
      if (!ct.includes('application/json')) throw new Error('Upstream HTML (not JSON): ' + text.slice(0,120));
      return JSON.parse(text);
    } finally {
      clearTimeout(wakeTimer); clearTimeout(abortTimer);
      if (statusEl.textContent.includes('Waking server')) setStatus('Ready.');
    }
  }
  async function apiManualClear(location, items){
    const body = new URLSearchParams();
    body.set('action', 'manual_clear');
    body.set('location', location || '');
    body.set('device_id', DEVICE_ID);
    body.set('items_json', JSON.stringify(items || []));
    const r = await fetch(API_BASE, { method:'POST', body });
    const ct = r.headers.get('content-type') || '';
    const text = await r.text();
    if (!r.ok || !ct.includes('application/json')) {
      throw new Error(`Manual clear failed (${r.status}): ${text.slice(0,160)}`);
    }
    return JSON.parse(text);
  }
  function makeLogId({ whenISO, code }) { return `${whenISO}|${code}|${getLocation()||''}|${DEVICE_ID}`; }
  async function apiDebugLog(sample){
    const whenISO = new Date(sample.ts || Date.now()).toISOString();
    const body = new URLSearchParams({
      action: 'rfid_debug',
      whenISO,
      device_id: DEVICE_ID,
      location: getLocation() || '',
      buffer: sample.buffer || '',
      events_json: JSON.stringify(sample.events || []),
    });
  
    try {
      await fetch(API_BASE, { method: 'POST', body });
    } catch (err) {
      // purely best-effort; no UI error needed
      console.warn('rfid_debug send failed', err);
    }
  }
  async function apiLog(entry){
    const whenISO = entry.whenISO || new Date().toISOString();
  
    // Derive a period key from the resolved record (same logic as class kiosks)
    let periodId = '';
    const res = entry.resolved;
    if (res && res.current_period != null) {
      periodId = String(res.current_period);
    } else if (res && res.next_period != null) {
      periodId = String(res.next_period);
    }

    const attendance = entry.attendance || (res && res.attendance) || '';
    
    const body = new URLSearchParams({
      action: 'log',
      log_id: makeLogId({ whenISO, code: entry.code || '' }),
      whenISO,
      code: entry.code || '',
      source: entry.source || 'pwa',
      resolved_name:  res?.name          || '',
      resolved_osis:  res?.osis          || '',
      resolved_lnum:  res?.locker_number || '',
      resolved_lcol:  res?.locker_color  || '',
      location: getLocation() || '',
      device_id: DEVICE_ID,
      allowed: entry.allowed || '',
      resolved_class: res?.class_now || ''
    });
  
    // Only send period_id if we actually have one
    if (periodId) {
      body.set('period_id', periodId);
    }
  
    try { await fetch(API_BASE, { method:'POST', body }); } catch {}
  }

  async function apiGetLocations(){
    try{
      const r = await fetch(API_BASE, {
        method:'POST',
        body: new URLSearchParams({ action:'locations' })
      });
      const ct   = r.headers.get('content-type') || '';
      const text = await r.text();
  
      if (r.ok && ct.includes('application/json')) {
        const data = JSON.parse(text);
      
        if (data && data.ok) {
          const arr = Array.isArray(data.meta)
            ? data.meta
            : (Array.isArray(data.locations) ? data.locations : []);
      
          __LOCATIONS_META = {};
          const visibleNames = [];
      
          for (const item of arr) {
            if (typeof item === 'string') {
              __LOCATIONS_META[item] = { type: null, mode: null, visible: true };
              visibleNames.push(item);
            } else if (item && typeof item === 'object') {
              const name  = String(item.name || '').trim();
              if (!name) continue;
      
              const type = item.type || null;
              const mode = item.mode || null;
              const vis  = (item.visible !== false);
      
              __LOCATIONS_META[name] = { type, mode, visible: vis };
              if (vis) visibleNames.push(name);
            }
          }
      
          if (data.caps && typeof data.caps === 'object') {
            __LOCATIONS_CAPS = data.caps;
          }
      
          return visibleNames;
        }
      }
    } catch(_) {}
  
    __LOCATIONS_META = {};
    STATIC_LOCATIONS.forEach(name => {
      __LOCATIONS_META[name] = { type: null, mode: null, visible: true };
    });
    return STATIC_LOCATIONS.slice();
  }
  async function checkDeviceLock(){
    try{
      const r = await fetch(API_BASE, { method:'POST', body: new URLSearchParams({ action:'device_location', device_id: DEVICE_ID }) });
      const ct = r.headers.get('content-type')||'';
      if (!r.ok || !ct.includes('application/json')) return;
      const data = await r.json();
      if (data.ok && data.locked && data.location) { IS_LOCATION_LOCKED = true; setLocation(data.location); }
    } catch(_) {}
  }
  async function apiRefreshRoster(){
    IS_REFRESHING = true;
    try {
      const r = await fetch(API_BASE, { method:'POST', body:new URLSearchParams({action:'refresh_mem'}) });
      return await r.json();
    } finally {
      IS_REFRESHING = false;
    }
  }

  /* ============================================================
   * HISTORY TABLE RENDER
   * ============================================================ */
  function pushPendingRow(seq, code, when){
    const tr = document.createElement('tr');
    tr.dataset.seq = String(seq);
    tr.innerHTML =
      `<td class="name"><em>‚Ä¶looking up‚Ä¶</em></td>
       <td class="code">${esc(code)}</td>
       <td>‚Äî</td>
       <td>${fmtTime(when)}</td>`;
    historyBody.prepend(tr);
    trimHistory();
    return tr;
  }

  function updateRowToSuccess(tr, {name, code, lockerNum, lockerColor, lunchValue, when}){
    const loc = getLocation();

    if (window.__lastSearchFlag) tr.classList.add('flag-search'); else tr.classList.remove('flag-search');

    const nameHtml = nameHtmlWithBadge(name);

    if (isSeniorOutIn() || isBathroomLocation(loc)) {
      const label = String(lockerNum||'').toUpperCase();
      const isOut = label === 'OUT', isIn  = label === 'IN', isNA = label === 'NOT ALLOWED';
      const pill = isOut
        ? `<span class="badge badge--out">ü´• OUT</span>`
        : (isIn ? `<span class="badge badge--in">üòê IN</span>`
                : `<span class="badge badge--na">NOT ALLOWED</span>`);
      const canGoOut = (isSeniorOutIn()) && !!window.__lastAllowedSenior;
      const allowBox = (canGoOut && !isNA)
        ? `<label class="flag"><input type="checkbox" checked disabled> Allowed to go out</label>`
        : '';
      tr.className = '';
      tr.innerHTML =
        `<td class="name">${nameHtmlWithBadge(name)}</td>
         <td class="code">${esc(code)}</td>
         <td>${pill} ${allowBox}</td>
         <td>${fmtTime(when)}</td>`;
      return;
    }

    if (isLunchLocation(loc)) {
      const allowed = isAllowedForLunch(loc, lunchValue ?? window.__lastLunchValue ?? '');
      const thirdCell = allowed
        ? `<span class="allowed-badge">‚úÖ Allowed</span>`
        : `<span class="not-allowed-badge">‚ùå Not allowed</span>`;
      tr.className = '';
      tr.innerHTML =
        `<td class="name">${nameHtml}</td>
         <td class="code">${esc(code)}</td>
         <td>${thirdCell}</td>
         <td>${fmtTime(when)}</td>`;
      return;
    }

    if (isClassKiosk(loc)) {
      const attendanceLabel = lockerNum || 'Present';
      const shouldRoom = lockerColor || '';
    
      const upper = String(attendanceLabel).toUpperCase();
      const showShould = (upper === 'NOT ALLOWED') && !!shouldRoom;
    
      const thirdCell = showShould
        ? `${esc(attendanceLabel)} <span class="muted">(should be ${esc(shouldRoom)})</span>`
        : esc(attendanceLabel);
    
      tr.className = '';
      tr.innerHTML =
        `<td class="name">${nameHtml}</td>
         <td class="code">${esc(code)}</td>
         <td>${thirdCell}</td>
         <td>${fmtTime(when)}</td>`;
      return;
    }

    const color = (lockerColor||'').trim();
    const cssColor = ({
      red:'#e53935', blue:'#1e88e5', green:'#43a047', yellow:'#fdd835',
      purple:'#8e24aa', orange:'#fb8c00', pink:'#d81b60', gray:'#78909c',
      grey:'#78909c', black:'#263238', white:'#fafafa', teal:'#009688'
    })[color.toLowerCase()] || null;
    const lockerHtml = (lockerNum || color)
      ? (cssColor
          ? `<span class="swatch" style="background:${cssColor}"></span>${esc(lockerNum||'')} <span class="muted">(${esc(color)})</span>`
          : `${esc(lockerNum||'')} <span class="muted">(${esc(color)})</span>`)
      : '‚Äî';

    tr.className = '';
    tr.innerHTML =
      `<td class="name">${nameHtml}</td>
       <td class="code">${esc(code)}</td>
       <td>${lockerHtml}</td>
       <td>${fmtTime(when)}</td>`;
  }

  function updateRowToNotFound(tr, code, when, error, reason){
    beepBad();
    const msg = error === 'invalid_input'
      ? (reason === 'leading_zero_osis' ? 'Leading-zero OSIS ‚Äî scan card.' : 'Digits only.')
      : 'Not found';
    tr.innerHTML =
      `<td class="name"><span class="bad">${esc(msg)}</span></td>
       <td class="code">${esc(code)}</td>
       <td>‚Äî</td>
       <td>${fmtTime(when)}</td>`;
  }
  function updateRowToError(tr, code, when, err){
    beepBad();
    tr.innerHTML =
      `<td class="name"><span class="bad">Lookup error</span></td>
       <td class="code">${esc(code)}</td>
       <td>‚Äî</td>
       <td>${fmtTime(when)}</td>`;
  }
  function trimHistory(){
    const loc = getLocation();
    let maxVisible;
  
    if (isSeniorOutIn()) {
      maxVisible = HISTORY_VISIBLE_SENIOR;
    } else if (isBathroomLocation(loc)) {
      maxVisible = BATHROOM_RECENT_VISIBLE;
    } else if (isClassKiosk(loc)) {
      maxVisible = HISTORY_VISIBLE_CLASS;
    } else {
      maxVisible = HISTORY_VISIBLE_DEFAULT;
    }
  
    while (historyBody.children.length > maxVisible) {
      historyBody.lastChild.remove();
    }
  }


  /* ============================================================
   * SCAN FLOW
   * ============================================================ */
  function normalizeForLookup(raw) {
    const s = String(raw || '').trim();
    if (!/^\d+$/.test(s)) return { ok:false, reason:'non_digit', norm:'' };
    const norm = s.replace(/^0+/, '');
    if (!norm) return { ok:false, reason:'all_zeros', norm:'' };
    return { ok:true, norm };
  }
  function markRowQueued(tr){
    const first = tr.querySelector('.name');
    if (first) first.innerHTML = '<span class="queued">Queued (offline)</span>';
  }

  async function onScanAsync(scanned){
    const when = new Date();
    const v = normalizeForLookup(scanned);
    if (!v.ok){
      beepBad();
      const msg = v.reason === 'non_digit' ? 'Digits only' : 'All zeros is not valid';
      resultEl.innerHTML =
        `<div class="err">${esc(msg)}</div>
         <div class="code">${esc(scanned)}</div>
         <div class="muted">${fmtTime(when)}</div>`;
      clearManualInput();
      setStatus('Ready.');
      return;
    }

    const code = v.norm;
    const row  = pushPendingRow(Date.now(), code, when);

    if (!navigator.onLine){
      markRowQueued(row);
      const q = JSON.parse(localStorage.getItem(QUEUE_KEY)||'[]');
      q.push({ seq: Date.now(), code, whenISO: when.toISOString() });
      localStorage.setItem(QUEUE_KEY, JSON.stringify(q));
      setStatus('Offline ‚Äî queued');
      return;
    }

    try {
      const res = await apiLookup(code);

      if (!res.found){
        updateRowToNotFound(row, code, when, res.error, res.reason);
        showNotFound(code, when);
        return;
      }

      window.__lastLunchValue    = res.lunch || '';
      window.__lastAllowedSenior = !!res.allowed_senior;
      window.__lastSearchFlag    = !!res.search;
      window.__lastRegentsPrep   = !!res.regents_prep;
      window.__lastAlertFlag     = !!res.alert;

      const loc     = getLocation() || '';
      const whenISO = when.toISOString();

      // üîî Auto-reset per period for class kiosks
      maybeResetClassStateForPeriod(res);

      // ---- CLASS KIOSK LOGIC ----
      if (isClassKiosk(loc)) {
        const kioskMode    = res.kiosk_mode || 'none';
        const kioskAllowed = !!res.kiosk_allowed;
        const shouldRoom   = res.kiosk_should_room || res.class_now || '';

        // No schedule context ‚Üí treat as NOT ALLOWED in class kiosks
        if (!kioskMode || kioskMode === 'none') {
          const attendance = 'Not allowed';
          updateRowToSuccess(row, {
            name: res.name,
            code,
            lockerNum: attendance,
            lockerColor: shouldRoom,
            when
          });
          showClassPopup(
            shouldRoom
              ? `You should be in ${shouldRoom} right now.`
              : 'This scanner is only for your scheduled class period.'
          );
          showClassRedirect(code, shouldRoom, when);
          apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:'kiosk_unknown' });
          setStatus('Ready. Scan next card‚Ä¶');
          return;
        }

        // Not allowed in this room
        if (!kioskAllowed) {
          const attendance = 'Not allowed';
          updateRowToSuccess(row, {
            name: res.name,
            code,
            lockerNum: attendance,
            lockerColor: shouldRoom,
            when
          });

          showClassPopup(
            shouldRoom
              ? `You should be in ${shouldRoom} right now.`
              : 'You should be in a different class right now.'
          );
          showClassRedirect(code, shouldRoom, when);
          apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:'kiosk_denied' });
          return;
        }

        const osis = String(res.osis || '').trim();
        const wasOut = !!OUT_OF_CLASS[osis];
        const isPresent = !!CLASS_PRESENT[osis];

        // First allowed scan of period ‚Üí take attendance, mark present
        if (!isPresent && !wasOut) {
          const attendance = res.attendance || 'Present';
          const attSlug = String(attendance).toLowerCase();
          const allowedValue = `kiosk_ok_first:${attSlug}`;
        
          CLASS_PRESENT[osis] = {
            firstIn: Date.now(),
            lastIn: Date.now()
          };
        
          // üîí Persist ‚Äúpresent this period‚Äù in localStorage
          if (CURRENT_CLASS_PERIOD_KEY) {
            const bucket = classBucketKeyFor(CURRENT_CLASS_PERIOD_KEY);
            const list   = getClassPresentList(bucket);
            if (!list.includes(osis)) {
              list.push(osis);
              setClassPresentList(bucket, list);
            }
          }
        
          updateRowToSuccess(row, {
            name: res.name,
            code,
            lockerNum: attendance,
            lockerColor: shouldRoom,
            when
          });
          showSuccess(res.name, code, attendance, shouldRoom, when);
          apiLog({ whenISO, code, source:'pwa', resolved:res, allowed: allowedValue });
          setStatus('Ready. Scan next card‚Ä¶');
          return;
        }

        // Present in class and not currently out ‚Üí open Out-of-Class modal
        if (isPresent && !wasOut) {
          CURRENT_CLASS_PENDING = { row, code, when, res, osis, shouldRoom };
          row.innerHTML =
            `<td class="name">${nameHtmlWithBadge(res.name)}</td>
             <td class="code">${esc(code)}</td>
             <td>Waiting for reason‚Ä¶</td>
             <td>${fmtTime(when)}</td>`;
          openOutModalForClass(CURRENT_CLASS_PENDING);
          setStatus('Select a destination for this student.');
          return;
        }

        // Currently out; scanning again ‚Üí back in
        if (wasOut) {
          const ctx = { row, code, when, res, osis, shouldRoom };
          await handleClassBackIn(ctx);
          return;
        }
      }

      // Senior Lunch (toggle OUT/IN)
      if (isSeniorOutIn()){
        const osis          = String(res.osis || '').trim();
        const allowedSenior = !!res.allowed_senior;
        const wasOut        = isOutNow(osis);

        if (!allowedSenior){
          updateRowToSuccess(row, { name: res.name, code, lockerNum: 'NOT ALLOWED', lockerColor: '', when });
          showSuccess(res.name, code, 'NOT ALLOWED', '', when);
          beepBad();
          apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:'not_allowed' });
          setStatus('Ready. Scan next card‚Ä¶');
          return;
        }

        if (wasOut) removeOut(osis); else addOut(osis, res.name || '', when);
        renderOutList();

        const statusText = wasOut ? 'IN' : 'OUT';
        updateRowToSuccess(row, { name: res.name, code, lockerNum: statusText, lockerColor: '', when });
        showSuccess(res.name, code, statusText, '', when);
        apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:(wasOut ? 'in' : 'out') });
        setStatus('Ready. Scan next card‚Ä¶');
        return;
      }

      // Bathroom IN/OUT with per-gender capacity
      if (isBathroomLocation(loc)) {
        const osis = String(res.osis || '').trim();
        const sex  = (String(res.sex || '').toUpperCase() === 'F') ? 'F' : 'M';
        const classNow = res.class_now || '';
      
        const wasIn = isInBathroomG(sex, osis);
      
        const cap = await getBathroomCapacity(loc, sex);
        const list = getBathSet(sex);
      
        if (wasIn) {
          removeFromBathroomG(sex, osis);
          await renderBathList();
          updateRowToSuccess(row, { name: res.name, code, lockerNum: 'OUT', lockerColor: '', when });
          showSuccess(res.name, code, 'OUT', '', when);
          apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:'out' });
          setStatus('Ready. Scan next card‚Ä¶');
          return;
        } else {
          if (list.length >= cap) {
            beepBad();
            updateRowToSuccess(row, { name: res.name, code, lockerNum: 'NOT ALLOWED', lockerColor: '', when });
            showSuccess(res.name, code, 'NOT ALLOWED', '', when);
            apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:`full_${sex}` });
            setStatus(`Capacity full (${list.length}/${cap}) ‚Äî please wait`);
            return;
          }
          addInBathroomG(sex, osis, res.name || '', when, classNow);
          await renderBathList();
          updateRowToSuccess(row, { name: res.name, code, lockerNum: 'IN', lockerColor: '', when });
          showSuccess(res.name, code, 'IN', '', when);
          apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:`in_${sex}` });
          setStatus('Ready. Scan next card‚Ä¶');
          return;
        }
      }

      // Lunch check
      if (isLunchLocation(loc)){
        const allowed = isAllowedForLunch(loc, res.lunch || '');
        updateRowToSuccess(row, { name: res.name, code, lockerNum:'', lockerColor:'', lunchValue:res.lunch||'', when });
        showSuccess(res.name, code, '', '', when);
        if (!allowed) beepBad();
        apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:String(allowed) });
        setStatus('Ready. Scan next card‚Ä¶');
        return;
      }

      // Default (Locker)
      const displayNum   = (res.locker_number_effective ?? res.locker_number) || '';
      const displayColor = (res.locker_color_effective  ?? res.locker_color)  || '';

      updateRowToSuccess(row, { name: res.name, code, lockerNum: displayNum, lockerColor: displayColor, when });
      showSuccess(res.name, code, displayNum, displayColor, when);
      apiLog({ whenISO, code, source:'pwa', resolved:res, allowed:'' });
      setStatus('Ready. Scan next card‚Ä¶');

    } catch (err) {
      if (!navigator.onLine || err.name === 'AbortError'){
        markRowQueued(row);
        const q = JSON.parse(localStorage.getItem(QUEUE_KEY)||'[]');
        q.push({ seq: Date.now(), code, whenISO: when.toISOString() });
        localStorage.setItem(QUEUE_KEY, JSON.stringify(q));
        setStatus('Offline ‚Äî queued');
        resultEl.innerHTML =
          `<div class="err">Queued (offline)</div>
           <div class="code">${esc(code)}</div>
           <div class="muted">${fmtTime(when)}</div>`;
      } else {
        updateRowToError(row, code, when, err);
        showError(err, code, when);
      }
    }
  }
  function onScan(scanned){
    if (IS_REFRESHING) { beepBad(); setStatus('Updating roster‚Ä¶ wait‚Ä¶'); return; }
    onScanAsync(scanned);
  }

  /* ============================================================
   * RESULT PANEL RENDER
   * ============================================================ */
  function showSuccess(name, code, lockerNum, lockerColor, when){
    const loc = getLocation();

    if (isSeniorOutIn() || isBathroomLocation(loc)) {
      const label = String(lockerNum||'').toUpperCase();
      const isOut = label === 'OUT';
      const isIn  = label === 'IN';
      const isNA  = label === 'NOT ALLOWED';
      const pill = isOut
        ? `<span class="badge badge--out">OUT</span>`
        : (isIn ? `<span class="badge badge--in">IN</span>`
                : `<span class="badge badge--na">NOT ALLOWED</span>`);
      const canGoOut = (isSeniorOutIn()) && !!window.__lastAllowedSenior;
      const allowBox = (canGoOut && !isNA)
        ? `<label class="flag"><input type="checkbox" checked disabled> Allowed to go out</label>`
        : '';
      const nameHtml = nameHtmlWithBadge(name);
      resultEl.innerHTML =
        `<div class="ok">OK</div>
         <div class="name">${nameHtml}</div>
         <div class="code">${esc(code)} ‚Äî ${pill} ${allowBox}</div>
         <div class="muted">${fmtTime(when)}</div>`;
      setStatus('Ready. Scan next card‚Ä¶');
      return;
    }

    if (isClassKiosk(loc)) {
      const attendanceLabel = lockerNum || 'Present';
      const shouldRoom = lockerColor || '';
    
      const upper = String(attendanceLabel).toUpperCase();
      const showShould = (upper === 'NOT ALLOWED') && !!shouldRoom;
    
      const extra = showShould
        ? `${attendanceLabel} ‚Äî should be ${esc(shouldRoom)}`
        : attendanceLabel;
    
      const nameHtml = nameHtmlWithBadge(name);
      resultEl.innerHTML =
        `<div class="ok">OK</div>
         <div class="name">${nameHtml}</div>
         <div class="code">${esc(code)} ‚Äî ${extra}</div>
         <div class="muted">${fmtTime(when)}</div>`;
      setStatus('Ready. Scan next card‚Ä¶');
      return;
    }

    const allowed = (isLunchLocation(loc) ? isAllowedForLunch(loc, window.__lastLunchValue||'') : null);
    const displayNum   = lockerNum   ?? '';
    const displayColor = lockerColor ?? '';

    const extra = isLunchLocation(loc)
      ? (allowed ? `<span class="allowed-badge">Allowed</span>` : `<span class="not-allowed-badge">Not allowed</span>`)
      : `Locker ${esc(displayNum || '‚Äî')} (${esc(displayColor || '‚Äî')})`;

    const nameHtml = nameHtmlWithBadge(name);
    resultEl.innerHTML =
      `<div class="ok">OK</div>
       <div class="name">${nameHtml}</div>
       <div class="code">${esc(code)} ‚Äî ${extra}</div>
       <div class="muted">${fmtTime(when)}</div>`;
    setStatus('Ready. Scan next card‚Ä¶');
  }

  function showNotFound(code, when){
    beepBad();
    resultEl.innerHTML =
      `<div class="err">Not found</div>
       <div class="code">${esc(code)}</div>
       <div class="muted">${fmtTime(when)}</div>`;
    setStatus('Ready.');
  }
  function showError(err, code, when){
    beepBad();
    resultEl.innerHTML =
      `<div class="err">Lookup error</div>
       <div class="code">${esc(code||'')}</div>
       <div class="muted">${fmtTime(when)} ‚Äî ${esc(err.message||String(err))}</div>`;
    setStatus('Ready.');
  }

  /* ============================================================
   * QUEUE (offline retries)
   * ============================================================ */
  function loadQueue(){ try{ return JSON.parse(localStorage.getItem(QUEUE_KEY)||'[]'); }catch{return [];} }
  function saveQueue(q){ localStorage.setItem(QUEUE_KEY, JSON.stringify(q)); }
  async function flushQueue(){
    if (!navigator.onLine) return;
    const q = loadQueue(); if (!q.length) return;
    const remain = [];
    for (const item of q){
      try{
        const res = await apiLookup(item.code);
        if (res.found){
          updateRowToSuccess(item.rowRef ?? pushPendingRow(item.seq, item.code, new Date(item.whenISO)), {
            name: res.name, code: item.code,
            lockerNum: res.locker_number, lockerColor: res.locker_color,
            when: new Date(item.whenISO)
          });
          apiLog({ whenISO:item.whenISO, code:item.code, source:'pwa', resolved:res });
        } else {
          updateRowToNotFound(item.rowRef ?? pushPendingRow(item.seq, item.code, new Date(item.whenISO)),
            item.code, new Date(item.whenISO), res.error, res.reason);
        }
      } catch { remain.push(item); }
    }
    saveQueue(remain);
  }
  window.addEventListener('online', flushQueue);
  flushQueue();

  /* ============================================================
   * KEYBOARD WEDGE + MANUAL ENTRY
   * ============================================================ */
  function keepFocus(){
    if (IS_MODAL_OPEN || isModalVisible()) return;
    if (document.activeElement !== manualInput) manualInput.focus({preventScroll:true});
    manualInput.setSelectionRange(manualInput.value.length, manualInput.value.length);
  }
  function isModalVisible() {
    const m = document.getElementById('locModal');
    if (!m) return false;
    return getComputedStyle(m).display !== 'none';
  }

  window.addEventListener('keydown', (e) => {
    if (IS_MODAL_OPEN || isModalVisible()) return;
  
    const loc = getLocation();
  
    // ===== RFID DEBUG MODE =====
    if (isDebugLocation(loc)) {
      // Always log the raw key
      handleDebugKey(e);
  
      // Still clear the textbox on Enter in debug mode
      if (e.key === 'Enter') {
        e.preventDefault();
        if (manualInput) manualInput.value = '';
      }
      return;
    }
  
    // ===== NORMAL MODE =====
    // Just keep the input focused; Enter handling is via the form submit
    keepFocus();
  }, true);

  document.getElementById('manualForm').addEventListener('submit', (e) => {
    e.preventDefault();
    if (IS_MODAL_OPEN || isModalVisible()) return;
  
    const v = manualInput.value.trim();
  
    // üîë Always clear on Enter *no matter what*
    clearManualInput();
  
    if (v) onScan(v);
    keepFocus();
  });

  keepFocus(); setInterval(keepFocus, 1000);

  /* ============================================================
   * BATTERY + NETWORK PILLS
   * ============================================================ */
  async function initBatteryPill(){
    const pill = document.getElementById('batteryPill');
    if (!pill || !navigator.getBattery) { pill && (pill.style.display='none'); return; }
    try {
      const batt = await navigator.getBattery();
      function fmt(b){
        const pct = Math.round((b.level || 0) * 100);
        const charging = b.charging;
        let ico = charging ? '‚ö°' : (pct <= 10 ? 'ü™´' : 'üîã');
        let extra = '';
        if (!charging && Number.isFinite(b.dischargingTime) && b.dischargingTime > 0) extra = ` ‚Ä¢ ${Math.round(b.dischargingTime/60)}m left`;
        else if (charging && Number.isFinite(b.chargingTime) && b.chargingTime > 0)   extra = ` ‚Ä¢ ${Math.round(b.chargingTime/60)}m to full`;
        pill.textContent = `${ico} ${pct}%${extra}`;
        pill.classList.remove('pill--bad','pill--warn');
        if (!charging && pct <= 10) pill.classList.add('pill--bad');
        else if (!charging && pct <= 25) pill.classList.add('pill--warn');
      }
      fmt(batt);
      batt.addEventListener('levelchange', fmt.bind(null, batt));
      batt.addEventListener('chargingchange', fmt.bind(null, batt));
      batt.addEventListener('dischargingtimechange', fmt.bind(null, batt));
      batt.addEventListener('chargingtimechange', fmt.bind(null, batt));
    } catch { pill.style.display='none'; }
  }
  function initNetworkPill(){
    const pill = document.getElementById('netPill');
    if (!pill) return;
    const navConn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    function fmt(){
      const online = navigator.onLine;
      let type = 'unknown', eff = '', mbps = '', rtt = '';
      if (navConn) {
        type = navConn.type || (online ? 'online' : 'offline');
        eff  = navConn.effectiveType ? ` ${navConn.effectiveType}` : '';
        if (typeof navConn.downlink === 'number') mbps = ` ‚Ä¢ ${Math.round(navConn.downlink)} Mbps`;
        if (typeof navConn.rtt === 'number' && navConn.rtt > 0) rtt = ` ‚Ä¢ ${navConn.rtt} ms`;
      } else type = online ? 'online' : 'offline';
      pill.classList.remove('pill--bad','pill--warn');
      if (!online){ pill.textContent='Offline'; pill.classList.add('pill--bad'); return; }
      if (navConn) {
        if (navConn.effectiveType === 'slow-2g' || navConn.effectiveType === '2g') pill.classList.add('pill--bad');
        else if (navConn.effectiveType === '3g') pill.classList.add('pill--warn');
      }
      const label = (type === 'wifi') ? 'Wi-Fi' : (type === 'ethernet' ? 'Ethernet' : type);
      pill.textContent = `${label}${eff}${mbps}${rtt}`;
    }
    fmt();
    window.addEventListener('online', fmt);
    window.addEventListener('offline', fmt);
    if (navConn && typeof navConn.addEventListener === 'function') navConn.addEventListener('change', fmt);
    else if (navConn) navConn.onchange = fmt;
  }

  /* ============================================================
   * ONLINE/OFFLINE + LOCATION PILL + WAKE LOCK
   * ============================================================ */
  function updateOnlinePill(){ const on = navigator.onLine; onlinePill.textContent = on ? 'Online' : 'Offline'; onlinePill.style.background = on ? '#eaf7ea' : '#fff3e0'; onlinePill.style.color = on ? '#0a7c2f' : '#8a5a00'; }
  window.addEventListener('online', updateOnlinePill);
  window.addEventListener('offline', updateOnlinePill);
  updateOnlinePill();

  function setModalOpen(v){ IS_MODAL_OPEN = !!v; }
  function updateLocationPill(){
    const pill = document.getElementById('locationPill');
    const v = getLocation();
  
    pill.textContent = v
      ? `Location: ${v}${IS_LOCATION_LOCKED ? ' (locked)' : ''}`
      : 'Set location';
  
    pill.style.background = v ? '#e7f0fe' : '#fff3e0';
    pill.style.color = v ? '#0b57d0' : '#8a5a00';
    pill.style.cursor = IS_LOCATION_LOCKED ? 'not-allowed' : 'pointer';
    pill.title = IS_LOCATION_LOCKED
      ? 'This device is locked to this location'
      : 'Click to change location';
  
    applyThemeForLocation(v);
    updateHeaderForLocation();
  }

  async function promptForLocation(force=false){
    if (IS_LOCATION_LOCKED) { alert(`This device is locked to ${getLocation()}.`); return; }
    if (!force && getLocation()) { updateLocationPill(); return; }

    const modal = document.getElementById('locModal');
    const sel   = document.getElementById('locSelect');
    const btnOK = document.getElementById('locSaveBtn');
    const btnX  = document.getElementById('locCancelBtn');

    sel.innerHTML = `<option value="">Loading‚Ä¶</option>`;
    modal.style.display = 'flex';
    setModalOpen(true);
    manualInput.blur();
    cardEl?.setAttribute?.('inert', '');
    setTimeout(() => sel.focus({ preventScroll: true }), 0);

    try {
      const list = await apiGetLocations();
      sel.innerHTML = `<option value="">Select a location‚Ä¶</option>` + list.map(v => `<option>${esc(v)}</option>`).join('');
      const saved = getLocation(); if (saved) sel.value = saved;
    } catch {
      sel.innerHTML = `<option value="">(Using defaults)</option>` + STATIC_LOCATIONS.map(v=>`<option>${esc(v)}</option>`).join('');
    }

    return new Promise(resolve=>{
      const close = (val) => {
        modal.style.display = 'none';
        setModalOpen(false);
        cardEl?.removeAttribute?.('inert');
        setTimeout(() => { keepFocus(); }, 0);
        resolve(val);
      };
      btnOK.onclick = () => {
        const val = sel.value.trim();
        if (val) { setLocation(val); updateHeaderForLocation(); close(val); }
        else { alert('Please choose a location.'); }
      };
      btnX.onclick = () => close(getLocation());
      modal.addEventListener('click', (ev)=>{ if (ev.target === modal) close(getLocation()); }, { once:true });
    });
  }

  (async () => {
    await checkDeviceLock();
    await apiGetLocations();
    updateLocationPill();
    updateHistoryPaneForLocation();
    trimHistory();
    await promptForLocation(false);
    await renderBathList();
  })();

  document.getElementById('locationPill').addEventListener('click', () => {
    if (IS_LOCATION_LOCKED) { alert(`This device is locked to ${getLocation()}.`); return; }
    promptForLocation(true);
  });

  // Wake Lock (keep screen on)
  let wakeLock = null;
  async function requestWakeLock() {
    if (!('wakeLock' in navigator)) return;
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', () => {
        if (document.visibilityState === 'visible') requestWakeLock();
      });
    } catch {}
  }
  document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') requestWakeLock(); });
  window.addEventListener('focus', requestWakeLock);
  window.addEventListener('keydown', requestWakeLock, { once: true });
  window.addEventListener('pointerdown', requestWakeLock, { once: true });

  // Init pills
  initBatteryPill();
  initNetworkPill();

  /* ============================================================
   * ROSTER REFRESH ‚Äî repurposed to CLEAR LIST for Senior Lunch
   * ============================================================ */
  document.getElementById('refreshRosterBtn')?.addEventListener('click', async (e)=>{
    const btn = e.currentTarget; btn.disabled = true; const original = btn.textContent;
    btn.textContent = 'Clearing‚Ä¶'; setStatus('Clearing list‚Ä¶');
    try {
      if (!isSeniorOutIn()) throw new Error('This button is for the "Senior Lunch (out-in)" location.');
      const loc = getLocation();
      const list = getOutSet();
      if (!list.length) { setStatus('Nothing to clear.'); return; }
  
      const items = list.map(r => ({ osis: r.osis, name: r.name }));
      const res = await apiManualClear(loc, items);
      setOutSet([]);
      renderOutList();
      setStatus(`Cleared ${res?.cleared ?? 0} student(s) from OUT list.`);
    } catch (err) {
      setStatus(`Clear failed ‚Äî ${err.message || err}`);
    } finally {
      btn.textContent = original; btn.disabled = false;
      setTimeout(()=> setStatus('Ready. Scan a card‚Ä¶'), 1200);
    }
  });

  </script>
</body>
</html>
